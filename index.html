<!DOCTYPE html>
<html lang="en-US">
<head>
    <meta charset="iso-8859-1">
    <meta http-equiv="content-type" content="text/html">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

    <title>Avraham Bernstein | Home Page</title> <!-- google uses just first 70 chars -->

    <!-- google meta tags -->

    <link rel="author" href="https://plus.google.com/110575620993497854880">
    <meta name="description" content="Avraham Bernstein, home page, CV, cybersecurity"> <!-- google uses just first 55 chars -->
    <meta name="keywords" content="Avraham Bernstein, Jerusalem, Israel, cybersecurity, cyber security, reverse engineering, obfuscation, pay TV, CTO, creativity, master S/W engineer, S/W architect, S/W quality, domain specific language, accessibility, blind">

    <!-- schema.org microdata -->

    <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "Person",
        "givenName": "Avraham",
        "familyName": "Bernstein",
        "additionalName": "Abe",
        "address": {
            "@type": "PostalAddress",
            "addressCountry": "IL",
            "addressLocality": "Jerusalem",
            "postalCode": "9727433",
            "streetAddress": "Mish'ol Ha'Uzrad 7/2"
        },
        "birthDate": "1956-01-01",
        "email": "Avraham DOT Bernstein AT gmail DOT com",
        "image": "http://purl.org/Avraham.Bernstein/image",
        "isicV4": "6209",
        "nationality": "IL",
        "telephone": "0546410955",
        "url": "http://purl.org/Avraham.Bernstein",
        "identifier": "2b965cdc-e10f-5258-9a33-eafcd54a3249"
    }
    </script>

    <!-- dcterms meta tags -->

    <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
    <meta name="dcterms.language" content="en-US">
    <meta name="dcterms.format" content="text/html">
    <meta name="dcterms.hasFormat" content="raw html">
    <meta name="dcterms.identifier" content="http://purl.org/avraham.bernstein">
    <meta name="dcterms.title" content="Avraham Bernstein | Home Page">
    <meta name="dcterms.hasVersion" content="Draft 0.7.10">
    <meta name="dcterms.date" content="2017-05-22">
    <meta name="dcterms.modified" content="2017-11-09T11:09:00Z">
    <meta name="dcterms.creator" content="Avraham Bernstein">
    <meta name="dcterms.rightsHolder" content="Avraham Bernstein, Jerusalem Israel">
    <meta name="dcterms.copyrightDate" content="2017">
    <meta name="dcterms.rights" content="All rights reserved">
    <meta name="dcterms.accessRights" content="http://creativecommons.org/licenses/by-nd/4.0/">
    <meta name="dcterms.audience" content="unrestricted">

    <meta name="dcterms.description" content="Avraham Bernstein, home page, CV">
    <meta name="dcterms.subject" content="Avraham Bernstein, Israel, Jerusalem, cybersecurity, cyber security, reverse engineering, obfuscation, pay TV, CTO, creativity, master S/W engineer, S/W architect, S/W quality, domain specific language, accessibility, blind">

    <style>
        .obf { display: none; }
        .readmore { background-color: cyan; }
        .readmore:before { content: "Read more >>>"; }
    </style>

    <!-- favicon -->
    <link  rel="icon" type="image/png" href="data:imag/png;base64,
iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QAAAAAAAD5
Q7t/AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3gUNDykqSsuRUgAAABl0
RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAFESURBVEjH7ZW9SgNB
FIW/tXDNjxA7iy1tgmJpa2FhaxEQBCuFRfAJfALfQGwEa7ETbaxESRHB3t7GoEYN
gn8ci9wNS5zsToqASO4w7My5Zzgz98ywASCGGGMMOf6rwDjQBB6AMGO1evoLcANs
AUF/mlhD3bbuyCc9q+12eY6FFynipYdAMi8jdgy77ydQNUIdcWXjWU8BECXDnjvz
3x7E9j0A9nqwvCgD2zY+d3kwgXhEtBGTiBDRRDwhCp4evCH2ERXXCVaBKeAYeAXe
gUOgYjmfKABLwIrrBHXbxWIKm0F8Wy7PgxAxhzgxPE6bPJ9z7WScPJNBTBt+my6R
j5HxgM84SkpUQrQQX4jIsaPIci1EcYASXScl2jTgNONRnRlnw/MlfyCWE4GGgbUM
gZpxGhkCn4g7xBFiocMJRj+ckcDfF/gBCTJDUqZhh4kAAAAASUVORK5CYII="/>

    <!-- google analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-17365003-2', 'auto');
      ga('send', 'pageview');
    </script>
</head>
<body>
<h1 tabindex="0" id="top">Avraham "Abe" Bernstein | Home Page</h1>
<address>
Version: Draft 0.7.10
<br>Last update: 2017-11-09T11:09:00Z
</address>
<p>
<figure>
<img title="Avraham Bernstein" alt="Avraham Bernstein" src="http://purl.org/avraham.bernstein/image" />
<figcaption>Secure<sup><a href="#secure-photo-footnote">1</a></sup> photo of the author, Avraham Bernstein, from 2017.</figcaption>
</figure>
<h2 tabindex="0" id="1.0">1.0 Contact Information</h2>
<p>

<strong>email &amp; skype:</strong>
<a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x41;&#118;&#114;&#x61;&#104;&#x61;&#x6d;&#46;&#66;&#x65;&#114;&#110;&#x73;&#116;&#x65;&#x69;&#110;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;" class="email">&#x41;&#118;&#114;&#x61;&#104;&#x61;&#x6d;&#46;&#66;&#x65;&#114;&#110;&#x73;&#116;&#x65;&#x69;&#110;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;</a>
&nbsp;<sup><a href="#anti-harvesting-footnote">2</a></sup>

<br><strong>geolocation:</strong> Jerusalem ISRAEL, <strong>tz:</strong> UTC +02:00/+03:00 [winter/summer]

<br><strong>tel:IL:mobile &amp; whatsapp:</strong>
<strong>
&#43;<span class="obf">@</span>&#57;<span class="obf">@</span>&#55;<span class="obf">@</span>&#50;<span class="obf">@</span>&#46;<span class="obf">@</span>&#53;<span class="obf">@</span>&#52;<span class="obf">@</span>&#46;<span class="obf">@</span>&#54;<span class="obf">@</span>&#52;<span class="obf">@</span>&#49;<span class="obf">@</span>&#45;<span class="obf">@</span>&#48;<span class="obf">@</span>&#57;<span class="obf">@</span>&#53;<span class="obf">@</span>&#53;
</strong>
&nbsp;<sup><a href="#anti-harvesting-footnote">2</a></sup>
&nbsp;<strong>[PREFERRED]</strong>

<br><strong>tel:US:work:</strong>
&#43;<span class="obf">@</span>&#49;<span class="obf">@</span>&#46;<span class="obf">@</span>&#56;<span class="obf">@</span>&#52;<span class="obf">@</span>&#53;<span class="obf">@</span>&#46;<span class="obf">@</span>&#52;<span class="obf">@</span>&#48;<span class="obf">@</span>&#50;<span class="obf">@</span>&#45;<span class="obf">@</span>&#48;<span class="obf">@</span>&#48;<span class="obf">@</span>&#50;<span class="obf">@</span>&#51;
&nbsp;<sup><a href="#anti-harvesting-footnote">2</a></sup>&nbsp;[SMS support]

<br><strong>tel:<a href="https://en.wikipedia.org/wiki/INum_Initiative">INUM</a>:</strong> +883.5100.0119-4962&nbsp;[via <a href="http://www.inum.net/what-is-inum-2/local-access-numbers/">local PSTN gateway</a> or <a href="sip:883510001194962@inum.net">sip:883510001194962@inum.net</a>]

<br><strong><a href="https://www.lifewire.com/what-is-sip-3426669">sip</a>:</strong> <a href="sip:avraham.bernstein@ekiga.net">avraham.bernstein@ekiga.net</a>

<br><strong>Jerusalem home address:</strong>
Mish'ol HaUzrad 7/2, Ramot Bet, Jerusalem 9727433 ISRAEL [<a href="https://www.google.com/maps/place/31.808472,35.200944">31.808472N, 35.200944E</a>]

<br><strong><a href="http://www.orenstransitpage.com/jlembusmap/jlembusmap.htm">Jerusalem public transit access</a>:</strong>
1 min. walk via bus lines 31, 32, &amp; 72 from <a href="https://www.google.com/maps/place/%D7%99%D7%92%D7%90%D7%9C+%D7%90%D7%9C%D7%95%D7%9F%2F%D7%A9''%D7%99%E2%80%AD/@31.8084194,35.200695,18.75z/data=!4m5!3m4!1s0x1502d611ce627b0d:0x85b254a042ae21b9!8m2!3d31.8089172!4d35.2007217?hl=en-US">bus stop 2263 Yigal Alon - Shai</a>, or a 10 min. walk (or transfer) via the many lines that stop at <a href="https://www.google.com/maps/place/Ramot+Junction%2FGolda/@31.8088152,35.2036742,18z/data=!4m5!3m4!1s0x1502d6055edc8dc9:0x9d0c1ea988bd94c2!8m2!3d31.8096483!4d35.2040617?hl=en-US">bus stop 5130 Tzomet Ramot</a>

<br><strong><a href="http://en.wikipedia.org/wiki/Shabbat">Shabbat Observant</a>:</strong>
Not available Fri. evening beginning 1 hour before sunset until Sat. night 1 hour after sunset, nor on <a href="http://www.timeanddate.com/calendar/?year=2017&amp;country=34">Jewish holidays</a>.

<br><strong><a href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy">pgp-id</a>:</strong>
<a href="https://pgp.mit.edu/pks/lookup?op=vindex&search=0x86EFCDAEE6647D2F">E6647D2F</a>,
<strong>pgp-asc:</strong> <a href="http://purl.org/Avraham.Bernstein/asc">AvrahamBernstein.asc</a>

<br><strong><a href="https://en.wikipedia.org/wiki/VCard">vcards</a>:</strong> <a href="http://purl.org/Avraham.Bernstein/vcard4">AvrahamBernstein-4.0.vcf</a>, <a href="http://purl.org/Avraham.Bernstein/vcard3">AvrahamBernstein-3.0.vcf</a>

<h3 tabindex="0" id="1.1">1.1 Links</h3>
<p>
<ul>
<li><strong>www-home:</strong> <a href="http://purl.org/Avraham.Bernstein">http://purl.org/Avraham.Bernstein</a></li>
<li><strong>cv-abbrev:</strong> <a href="http://purl.org/Avraham.Bernstein/cv/abbrev.html">HTML (easiest to read)</a>, <a href="http://purl.org/Avraham.Bernstein/cv/abbrev.pdf">PDF</a>, <a href="http://purl.org/Avraham.Bernstein/cv/abbrev.docx">DOCX</a></li>
<li><strong>cv-full:</strong> <a href="http://purl.org/Avraham.Bernstein/cv/full.html">HTML</a>, <a href="http://purl.org/Avraham.Bernstein/cv/full.pdf">PDF</a>, <a href="http://purl.org/Avraham.Bernstein/cv/full.docx">DOCX</a></li>
<li><strong>linkedin:</strong> <a href="https://www.linkedin.com/in/AvrahamBernstein">https://www.linkedin.com/in/AvrahamBernstein</a></li>
<li><strong>github:</strong> <a href="https://github.com/Avraham-Bernstein">https://github.com/Avraham-Bernstein</a> [under construction]</li>
<li><strong>professional blog:</strong> <a href="http://purl.org/Avraham.Bernstein/blog">http://purl.org/Avraham.Bernstein/blog</a> [under construction]</li>
<li><strong>personal blog on google+:</strong> <a href="https://plus.google.com/110575620993497854880">https://plus.google.com/110575620993497854880</a>&nbsp;<sup><a href="#anti-harvesting-footnote">2</a></sup> [out of date]</li>
<!-- anti-harvesting: abbrev google+ url reveals email address -->
<li><strong>twitter:</strong> <a href="https://twitter.com/avrhmbernstein">@avrhmbernstein</a> [currently just a lurker]</li>
<li><strong>secure peer-to-peer file transfer:</strong> <a href="http://www.omgubuntu.co.uk/2017/06/wormhole-fast-secure-way-send-files-users-cli">wormhole</a></li>
</ul>

<h2 tabindex="0" id="2.0">2.0 About: Professional</h2>
<p>
<details><summary>
I am a CTO level computer scientist and technologist.
I am still engaged in state-of-the-art hands-on programming.
Due to the unusual nature of the problems that I face,
I usually need to build working prototypes as part of the specification process.
From 2004-17, I worked in the field of cybersecurity for the pay TV industry.
From 2004-09, I worked at <a href="http://www.cisco.com/c/en/us/about/corporate-strategy-office/acquisitions/nds.html">Cisco-NDS</a>
as a security researcher on their
<a href="https://en.wikipedia.org/wiki/Conditional_access">CA (conditional access)</a>
<a href="https://en.wikipedia.org/wiki/Set-top_box">set-top box</a> and
<a href="https://en.wikipedia.org/wiki/Smart_card">smart card</a> pay TV systems.
From 2011-17, I worked at <a href="http://www.viaccess-orca.com">Viaccess-Orca</a> - a wholly owned subsidiary of Orange France,
as head of security for their Internet OTT (over-the-top) Android and IOS pay TV product, "Secure Player".
During the 6 years of my tenure as head of security for the OTT product,
we had tens of millions of subscribers, while we were never successfully hacked in the field.
<p>
As head of security for the Viaccess-Orca OTT product,
the purpose of my work was to prevent the theft of intellectual property (aka anti-piracy),
namely to protect the
<a href="https://en.wikipedia.org/wiki/Digital_rights_management">DRM (digital rights management)</a>
application that we loaded into subscriber devices against
<a href="https://en.wikipedia.org/wiki/Reverse_engineering">reverse engineering</a>.
Most important, I had to protect the secret keys that were stored on the subscriber devices from leaking,
i.e. the subscriber keys and the content decryption keys.
The core security module that we loaded into the subscriber devices was a
<a href="https://en.wikipedia.org/wiki/Binary_code">binary (native machine code)</a> library written in C/C++,
where just the <a href="https://en.wikipedia.org/wiki/Graphical_user_interface">GUI (graphic user interface)</a>
wrapper was written in Java and Objective-C for Android and IOS devices respectively.
Note that it is 10-100 times more complex to reverse engineer C/C++ code compared to Java or Objective-C code.
I used state-of-the-art <i>binary</i> <a href="https://en.wikipedia.org/wiki/Obfuscation_(software)">software obfuscation</a>
techniques in order to outsmart state-of-the-art reverse engineering
<a href="https://en.wikipedia.org/wiki/Assembly_language">assembly code</a>
<a href="https://en.wikipedia.org/wiki/Debugger">debuggers</a>.
<p>
[Note the difference between CA and OTT:
Using the US as an example, a very popular CA product is <a href="https://www.directv.com">DirecTV</a> delivered via satellite,
where the cost of a monthly subscription is $50-125 plus a premium of $5 per video-on-demand.
Since the mid-1990s almost every household had a CA satellite or cable TV subscription.
The most popular OTT product is <a href="https://www.netflix.com">Netflix</a> delivered via Internet,
where the cost of a monthly subscription is $10 with unlimited access to about 4K videos.
As a result of the now ubiquitous high speed inexpensive Internet to the home,
by mid-2016 the <a href="https://en.wikipedia.org/wiki/The_Tipping_Point">tipping point</a>
of consumer preference for OTT had been reached.
By Q1-2017 hundreds of thousands of CA subscribers per month were "cutting the cord".
They were cancelling their CA subscriptions, and switching to OTT. The number of Netflix subscriptions exceeds all CA cable subscriptions.]

<h3 tabindex="0" id="2.1">2.1 Work Experience at Viaccess-Orca</h3>
My main tasks at Viaccess-Orca were the following:
<br><span class="readmore"/>
</summary>
<ol>

<li>My most important task was to specify and architect a security policy, and to supervise its implementation. And to keep abreast of the latest Android and IOS security issues.
<p>
</li>

<li>I provided the developers with cryptographic, anti-reverse engineering, and software obfuscation tools.
<p>
</li>

<li>Some of the tools we purchased, most notably the following superb<sup><a href="#scp-footnote">3</a></sup> (but expensive) tools from <a href="https://www.whitecryption.com">WhiteCryption</a>:
<ol>
<li>SCP: an "obfuscating" compiler for C/C++ that generates obfuscated C/C++ code.
</li>
<li>SKB: a "whitebox" cryptographic library, that implements standard cryptographic operations on "wrapped" keys that are prepared with a preprocessor.
</li>
<li>I was the liaison with WhiteCryption. And I provided in-house support and configuration of these tools.
</li>
<li>I worked together with WhiteCryption, in order to specify an improvement to their <a href="https://upx.github.io/">UPX-like</a> dynamic shared object (DSO = <code>.so</code> or <code>.dll</code>) library packer utility.
Their original utility packed and encrypted a DSO for file storage, while automatically unpacking and decrypting itself just as it loads itself into memory.
Even though an attacker could not execute a <a href="https://en.wikipedia.org/wiki/Static_program_analysis">static code analysis (for the purpose of reverse engineering)</a> of the object code while it was packed and encrypted on disk,
once he creates a trivial "reconnaissance" app that loads the library into his process memory, then he can dump memory,
and still execute a static code analysis on the dump. We added a feature that will permit only authorized users of the DSO to load it,
otherwise it won't decrypt and unpack itself. The most important aspect of this feature is that it can be done to any DSO without the
knowledge or cooperation of the one originally built it.
</li>
</ol>

<p><li>
<details id="vo-inhouse-tools">
<summary>
Some tools we developed in-house, where I would be in charge of their development.
Some of the more notable tools and techniques that I developed were the following:
<br><span class="readmore"/>
</summary>

<ol>

<li>An Android "root" detection and security module. This project required considerable research. In many cases the determination of whether or the not the O/S is rooted is not a straight-forward binary checklist. Therefore it required the use of <a href="https://en.wikipedia.org/wiki/Fuzzy_logic">fuzzy logic</a>.
<p></li>

<li>A distributed <i>light weight</i> cryptographic library implemented solely as a C header (.h) file as opposed to being associated with a common binary object module.
This allowed each module that used it to have its own customized version of the library implemented as <code>static</code> or <code>inline</code> C source code functions which made it impossible for an attacker to identify and to subvert a single common cryptographic module.
Typically the overhead was less than 1K bytes of object code per module that included this library.
An outstanding technical hack in this module was having the C <i>preprocessor</i> encrypt strings using a stream cipher (where the string was specified as list of individual characters, e.g. "abc" = {'a','b','c',0}),
so that the in-the-clear string would not be visible post-compilation in the object code.

<ol>
<p><li>
Even though every module that included the library shared a common .h file, we needed some techniques to customize each module's version of it.
At the beginning of every C/C++ module, the following code provides the infrastructure to enable every instance to have its own unique IV.
<pre><code>
// FILE: zulu.c
#define MODULE MODULE_ZULU

#include "module-list.h"
// module-list.h: this file includes a list of all the modules in the system, e.g.
// #define MODULE_ALPHA 1
// #define MODULE_BRAVO 2
// ...
// #define MODULE_ZULU 99

#include &lt;stdint.h&gt;

#include "random-list.h"
// random-list.h: this file includes an automatically generated list of unique random numbers Ri_j in the following format:
// #define RAND_1   UINT64_C(R1_0),   UINT64_C(R1_1),  UINT64_C(R1_2), ...,  UINT64_C(R1_63) // for MODULE_ALPHA
// #define RAND_2   UINT64_C(R2_0),   UINT64_C(R2_1),  UINT64_C(R2_2), ...,  UINT64_C(R2_63) // for MODULE_BRAVO
// ...
// #define RAND_99  UINT64_C(R99_0), UINT64_C(R99_1), UINT64_C(R99_2), ..., UINT64_C(R99_63) // for MODULE_ZULU

#include "random.h"
// random.h: macros
// #define CALL(macro_name,...) macro_name(__VA_ARGS__)  // more simple than the Boost cpp EVAL/DEFER syntax
// #define CONCAT(x,y)          __CONCAT(x,y)  // deferred version of __CONCAT which is the std compiler wrapper for the cpp paste operator
// #define SELECT(i)            CONCAT(SELECT_,i)
// #define SELECT_0(x0,...) x0  // Boost cpp technique
// #define SELECT_1(x0,x1,...) x1
// ...
// #define SELECT_63(x0,x1,...,x63,...) x63
// #define RAND(i)              CALL(SELECT(i),CONCAT(RAND_,MODULE))  // we need to defer because the 2nd arg must expand to a list

#include "lwc.h" // light weight crypto library
// static uint64_t lwc_iv[16] = { RAND(0), RAND(1), ..., RAND(15) }; // every instance has a unique IV
</code></pre>
</li>

<li>
In order to make sure the each module specific IV is not the same for every instantiation,
 a tiny <code>static void lwc_init()</code> function is used to read <code>/dev/urandom</code> in order to refresh the IV. (And note that each module encrypted the string "/dev/urandom" differently - by using a different stream cipher IV).
<p></li>

<li>
In order to make every instance of the same cryptographic function seem different to a <i>cursory</i> analysis of its binary,
and in order to hide the easily identifiable coefficients, many of which uniquely identify the algorithm via an Internet search,
we obfuscate the coefficients as follows:
<pre><code>
static uint64_t lwc_zero = 1; // set to zero in lwc_init()
static uint64_t lwc_mycrypto_func(...) {
   static const uint64_t obf_coeff_a = LWC_COEFF_A ^ RAND(0);
   static const uint64_t obf_coeff_b = LWC_COEFF_B ^ RAND(1);
   uint64_t coeff_a = (obf_coeff_a + lwc_zero) ^ RAND(0);
   uint64_t coeff_b = (obf_coeff_b + lwc_zero) ^ RAND(1);
   // execute algorithm ...
}
</code></pre>
And of course we rely upon our obfuscating compiler to scramble each instance of the code differently.
</li>
</ol>
<p></li>

<li>I specified an architecture (but did not yet implement) the creation of a usable dynamic shared object (DSO = <code>.so</code> or <code>.dll</code>) library that exports no symbols!
<ol>

<li>We typically had vendor partners who supplied us with a player "codec", <code>codec.so</code>, who did not take security seriously.
Even though we UPX wrapped their DSO, once it was finally loaded into process memory,
a determined attacker could use their unprotected code as a vector for attacking our own heavily secured library,
<code>drm.so</code>. This is our "Achilles' heel".
</li>

<li>First I tried to suggest to the vendor that he purchase the inexpensive (~$5K for a commercial license) <a href="http://tigress.cs.arizona.edu/">Tigress obfuscating compiler</a> developed by <a href="https://www2.cs.arizona.edu/~collberg/">Christian Collberg</a>, one of the most well known academics in the field of obfuscation. But the vendor refused.
</li>

<li>We provide the vendor with our <code>drm-api.h</code> file that specifies our "secret" API interface that we normally export in the global symbol table of our own DSO, <code>drm.so</code>.
</li>

<li>The vendor has many clients, and typically does a single common build of their library for all of them.
</li>

<li>We needed to protect our own DSO, <code>drm.so</code>, by hiding all of its exported symbols, and we needed to obfuscate how the vendor's DSO, <code>codec.so</code>, called our API.
</li>

<li>My solution was to provide the vendor with a tiny generic "shim", i.e. a tiny C module with source code, that he agreed to incorporate into his own DSO, <code>codec.so</code>, the same library that he distributed to all of his clients, regardless of whether or not they knew how to take advantage of the shim.
</li>

<li><i>Eventually</i> we could do a binary edit of <code>codec.so</code>, and add the shim function without the vendor's knowledge or support as long as the vendor doesn't sign his code. Tools that edit ELF files include <a href="http://www.eresi-project.org/">ESRI</a> and <a href="http://docs.pwntools.com/en/stable/index.html">pwntools</a>.
</li>

<li>The shim function that immediately follows is deceptively simple. It provided me with enough of a beachhead into the vendor's code, that I could supply our DSO with no global symbols, and I could obfuscate his calls to our secret APIs.
<pre><code>
/*
FILE: shim.c
DESCRIP: Shim interface to a DSO that exports no symbols
DATE: 2017-05-16T17:07:00Z
AUTHOR: Avraham DOT Bernstein AT gmail
COPYRIGHT (c) 2017 Avraham Bernstein, Jerusalem ISRAEL. All rights reserved.
LICENSE: Apache License, Version 2.0: https://opensource.org/licenses/Apache-2.0
*/
#include &lt;stdlib.h&gt;
#include &lt;dlfcn.h&gt;

// gShim is a global var that can be used by anyone who uses the shim.

// In our particular case we will use it receive the address of an obfuscated
// and randomized jump table that drm-api.h will wrap with macros to make them
// appear like regular function calls

void * gShim;

__attribute__((constructor)) // stealth load before dlopen completes!
static void shim() // note func is static so it will not be an exported symbol
{
  // The only way to communicate with this func is via the env var CODEC_VENDOR_NAME_SHIM_LIB.

  // BTW if the codec vendor's name is ALPHA, then the name of this variable
  // should really be ALPHA_SHIM_LIB.

  // If no value is assigned to this env var, or it is not the name of a
  // dynamic library, or it has no "init" func, then this function will do
  // nothing and return immediately.

  const char * lib = getenv("CODEC_VENDOR_NAME_SHIM_LIB"); // TODO: obfuscate this string
  if (lib && *lib) { // verify that env var exists and has a value

    void * h = dlopen(lib,RTLD_NOW); // attempt to load DSO lib

    if (h) {
      typedef void * (*InitFunc_t)();
      InitFunc_t initFunc = (InitFunc_t)dlsym(h,"init"); // get addr of lib's init func

      if (initFunc) {

        gShim = (*initFunc)(); // invoke lib's init func

        // Anyone who uses the shim can have init() return any value they please.

        // In our particular case init() will communicate with drm.so via an
        // asynchronous encrypted back channel that it prepared just before it
        // made the call to dlopen("codec.so")

        // The channel must be asynchronous because communication will take place
        // *before* the dlopen("codec.so") call completes
      }

      dlclose(h);
    }
  }
}
</code></pre>
</li>

</ol>
</li>

<li>
    I specified an architecture (but did not yet implement) to implement a just-in-time obufuscation of every system call with negligible overhead.
    This is useful because the commercial reverse engineering tools, such as <a href="https://www.hex-rays.com/">HEX-RAYS</a>,
    "light up" the assembly code by automatically placing an anchor wherever there is a direct call to a system function. But it can't automatically
    "light up" the assembly code when indirect calls are used. Clearly HEX-RAYS is aware that a system call is made as soon as it is jumped into.
    So we will modestly categorize this technique as being a "speed bump". However we could create an <i>application specific libc</i> with open source
    package such as <a href="https://www.musl-libc.org/">musl</a> with a permissive MIT license. It would not be a trivial project because musl is
    designed to replace libc - as opposed to coexists with it.
    But if we could do it, then we could blind a rooted attacker who is used to having the ability to "hook" the built-in system calls to libc.
    <p>
    In a similar vein, if we were to use Sqlite then we could create a custom obfuscated version.
    Sqlite is a very small package.

<pre><code>
// Naive implementation.
// Note we are using dlopen/dlsym in order to avoid relocation entries!

#define LIBC_SO "libc.so.6"

int obf_open(const char * filename, int flags) {
    typedef int (*open_t)(const char * filename, int flags);

    static uintptr_t r1 = 0;
    static uintptr_t r2 = 0;

    if (r1 == 0) {
        r1 = prng_next(); // guaranteed never to return 0
        assert(r1);

        void * h = dlopen(LIBC_SO, RTLD_NOW);
        assert(h);

        r2 = (uintptr_t)dlsym(h,"open");
        assert(r2);

        r2 ^= r1;
        dlclose(h);
    }

    open_t f = (open_t)(uintptr_t)(r1 ^ r2);
    return (*f)(filename,flags);
}
</code></pre>

The following is a more efficient implementation:

<pre><code>
// compile switches: -std=c11|-std=c++11 -ldl

#ifdef __GNUC__
#define GCC_ATTRIB(...) __attribute__((__VA_ARGS__))
#else
#define GCC_ATTRIB(...)
#endif

#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))
#define CONCAT(x,y) __CONCAT(x,y)

#ifdef __cplusplus
#define INLINE inline
#else
#define INLINE static inline
#endif

#define LIBC_SO "libc.so.6"

// The overhead of this scheme is a tiny inline function per libc call that is in fact actually used.
// For a slightly higher price every module can also have their own static libc_init()
// function where a preprocessor will generate a module specific permutation of the
// enum immediately below.

// Note that this an ideal module to be built using a macro preprocessor template
// engine such as Jinja2. And if we used Jinja2 then we could automatically
// assign the appropriate GCC attributes to each function.

typedef enum {
    OBF_LIBC_close,
    OBF_LIBC_open,
    OBF_LIBC_read,
    OBF_LIBC_write,
    // ...
    OBF_LIBC_END
} Obf_Libc_Names_t;

typedef struct {
    uintptr_t r1,r2;
} Obf_Addr_t;

typedef struct {
    int n; // len of name incl trailing zero - required for decryption
    const char * name;
    Obf_Addr_t addr;
} Obf_Libc_Entry_t;

Obf_Libc_Entry_t obf_libc_tbl[] = { {6,"close"}, {5,"open"}, {5,"read"}, {6,"write"}, /* ... */ }; // TBD: encrypt strings

static_assert( ARRAY_SIZE(obf_libc_tbl) == OBF_LIBC_END, "error: sizeof(obf_libc_tbl)" );

void obf_libc_init()
{
    typedef int     (*dlclose_t)(void * handle);
    typedef void *  (*dlopen_t)(const char * filename, int flags);
    typedef void *  (*dlsym_t)(void * handle, const char * symbol);

    Obf_Addr_t obf_dlclose, obf_dlopen, obf_dlsym;

    int i;
    uintptr_t r1,r2;

    r1 = prng_next();
    r2 = (uintptr_t)dlclose;
    obf_dlclose.r1 = r1;
    obf_dlclose.r2 = r1 ^ r2;

    r1 = prng_next();
    r2 = (uintptr_t)dlopen;
    obf_dlopen.r1 = r1;
    obf_dlopen.r2 = r1 ^ r2;

    r1 = prng_next();
    r2 = (uintptr_t)dlsym;
    obf_dlsym.r1 = r1;
    obf_dlsym.r2 = r1 ^ r2;

    void * h = (*(dlopen_t)(obf_dlopen.r1 ^ obf_dlopen.r2)) (LIBC_SO, RTLD_NOW); // TBD: decrypt string
    assert(h);

    for (i = 0; i < OBF_LIBC_END; ++i) {

        r1 = prng_next();
        assert(r1);

        r2 = (uintptr_t) (*(dlsym_t)(obf_dlsym.r1 ^ obf_dlsym.r2)) (h,obf_libc_tbl[i].name); // TBD: decrypt string
        assert(r2);

        obf_libc_tbl[i].addr.r1 = r1;
        obf_libc_tbl[i].addr.r2 = r1 ^ r2;
    }

    i = (*(dlclose_t)(obf_dlclose.r1 ^ obf_dlclose.r2)) (h);
    assert(i == 0);
}

#define OBF_LIBC_FUNC_DEF(_name, _ret_t, _signature, _args) \
GCC_ATTRIB(unused) INLINE _ret_t CONCAT(obf_,_name) _signature { \
    typedef _ret_t (*func_t) _signature; \
    Obf_Libc_Names_t _i = CONCAT(OBF_LIBC_, _name); \
    func_t _func = (func_t)(obf_libc_tbl[_i].addr.r1 ^ obf_libc_tbl[_i].addr.r2); \
    return (*_func) _args; \
}

OBF_LIBC_FUNC_DEF(close, int, (int fd), (fd))
// ==> INLINE int obf_close(int fd) { ... }

OBF_LIBC_FUNC_DEF(open,  int, (const char * filename, int flags), (filename,flags))
// ==> INLINE int obf_open(const char * filename, int flags) { ... }

OBF_LIBC_FUNC_DEF(read,  int, (int fd, void * buf, ssize_t n), (fd,buf,n))
// ==> INLINE int obf_read(int fd, void * buf, ssize_t n) { ... }

OBF_LIBC_FUNC_DEF(write, int, (int fd, const void * buf, ssize_t n), (fd,buf,n))
// ==> INLINE int obf_write(int fd, const void * buf, ssize_t n) { ... }

#define close obf_close
#define open obf_open
#define read obf_read
#define write obf_write
</code></pre>
<p>
</li>

<li>
I specified an architecture (but did not yet implement) to handle the application
update mechanism which is uniquely problematic to our industry.
We provided our customers with an application framework which they tailored to their own needs,
and which they were responsible to deploy to their subscribers.
When we needed to update the core libraries or configuration files,
say for an important security patch, we were not able to use Google's Play Store to push the updates
to our customers' subscribers because we have no access to their app's enterprise keys,
and they have no intention of ever revealing their keys to us.
When we inform our customers of the necessity to apply an important security patch,
they could easily take 3-6 months before applying it.
Our customers were petrified that our change,
because it was never vetted by their own QA department,
would cause their app to crash,
that would cause an avalanche of tens of thousands of subscriber complaints to
their own customer service department.
From our perspective it could take up to 6 months to stop hemorrhaging from a compromised key.
One solution would be to place a built-in 120 day "kill switch" in our core libraries that
would force our customers to always update the core system about every 90 days.
Currently our EULA says 180 days, but we never enforced it.
A second solution would be for our customers to trust us,
and use the Google Enterprise tools to delegate authority to us to make updates.
And a third solution would be a hack.
We could supply a VO (Viaccess-Orca) app that was automatically installed
along with the customer's app, and automatically activated every time the customer's
app was activated.
The VO app would be defined to automatically receive the latest updates.
If the VO app were not running, then neither could the customer's app.
The customer app would open up a communication channel with the VO app to see
whether any updates should be applied. If an update were necessary then the
communication channel would copy them to the customer app.
Of the 3 possibilities, I think that the "kill switch" would be the best compromise;
although having a VO app (that was always updated) running in the background may open
up some interesting possibilities even if we refrained from automatically updating the
files in the customer's app.
<p></li>

<li>Whenever technically feasible,
I preferred doing my development work on an Android VM (virtual machine).
Also whenever technically feasible I preferred writing tiny Android command line
applications when testing out new O/S concepts.
The standard practice of creating a full fledged Android GUI application via the
Gradle IDE was bloated in comparison.
</li>

</ol>
</details>
<p>
</li>

<li>
The above perfect theft rate statistic is not necessarily a good predictor of the future.
One of our most important security components was detecting whether or not the Android device was "rooted".
I personally spent quite a bit of effort developing and honing this algorithm.
Originally when we detected that a device was rooted then we would refuse to play protected content on that device,
because a rooted device no longer conforms to Android's security model which effectively nullifies all of the O/S built-in protection mechanisms.
But the new reality of the Android device market that we face is that 25% of Android devices are rooted off-the-shelf.
These rooted devices are usually much less expensive, by at least 50%, than the brand name OEM devices.
The major content providers (e.g. Disney, Sony, Warner Bros., etc.) can no longer afford to <i>a priori</i> disqualify rooted devices.
They would lose too much royalty revenues.
Therefore the new security algorithms must become more sophisticated ones that can detect and respond only when a device is under attack or under threat of imminent attack, regardless of whether or not the device is rooted.
For example, when a <i>known</i> debugger process is active, then we would consider the threat to be imminent.
Unfortunately it is impossible to detect all possible attack vectors.
For example, it would be much more difficult to detect a hacker who wrote his own custom debugger.
Therefore in this new reduced security Android environment, both device internals logging and network activity logging become essential security components.
Often the only way to spot a pirate is to monitor his activities after the fact by using these log files.
<p>
From a commercial perspective it is extremely interesting to note that Google Widevine adamantly refuses to play on these "uncertified" rooted devices.
Note that Netflix uses Widevine.
Even though Widevine certification is officially free, it is an extremely time consuming and expensive process for small Android vendors. (What typifies these vendors is that they refuse to spend even the extra hour to request enterprise keys from Google, and then to build a non-rooted Android version with their enterprise keys instead of the test keys). Among the other certification requirements, the vendor must send, at his own expense, two programmers to a one week course at a US Google facility.
</li>
</ol>


</details>

<h3 tabindex="0" id="2.2">2.2 Economics of Security in the Pay TV Industry</h3>
<p>
<details>
<summary>
Besides requiring a high degree of technical skills, managing security requires a high degree of economic skills too.
<i>A priori</i> we have a very strong preference to minimize "false positives", namely we cannot afford to make a mistake when our AI rules conclude that a device is stealing content, and our software begins to take evasive actions.
The consequences of having "a light finger on the trigger" would be disastrous.
Hundreds or even thousands of <i>bona fide</i> subscribers will complain to customer support.
Besides the important element of lack of goodwill which could cause subscribers to cancel their subscriptions and publicize their complaints on the Internet, simply the cost of handling a subscriber support call is very high.
Too many such calls can significantly eat into an operator's profit margins.
The duality of a low threshold for false positives, is being forced to accept a high level of false negatives, i.e. we will substantially decrease our detection rate when a real theft is taking place.
<br><span class="readmore"/>
</summary>

Given that the cost of implementing security measures is sometimes very expensive, we need to do a cost-benefit analysis before we implement.
<ol>
<li>We have to understand the economic consequences of theft, and we have to make a realistic estimate of what our base line theft rate is.
</li>
<li>We have to estimate the development cost, and the variable costs associated with adding a new feature. Usually this is the most accurate estimate we make compared to the other items in this list.
</li>
<li>We have to estimate how much the incorporation of this new feature will reduce theft rate.
</li>
<li>Finally we have the economic tools to quantify the economic benefit of adding the new feature.
</li>
</ol>

<p>
One way of significantly improving security of the overall system, while reducing security on devices, is simply to analyze the activity logs on the operator's content servers. For example an easy and inexpensive technique is simply to analyze these logs in order to detect that a particular subscriber is downloading an unreasonable amount of content per week (e.g. 100 hours), the subscriber is simultaneously downloading content from IP addresses at widely different geographic locations around the world (e.g. NY and London).

<p>
On the other hand, logging the internal activity inside individual devices can become very expensive when we tally the extra communication costs associated with tens of millions of subscriber devices. However many subscribers complain to their operators that the security algorithms are unreasonably restrictive. For every subscriber that complains, maybe 10 do not. Therefore when new features are added to the system, whether security related or not, logging of internal device activity is crucial. But such information usually must be encrypted, otherwise it may reveal secrets that could compromise system security. But using industrial strength encryption during playback, may consume too much CPU, and
compromise the quality of the playback. Etcetera.

<p>
Today (2017) the legacy CA pay TV industry is experiencing economic <i>convulsions</i>.
These convulsions are due to the <a href="https://en.wikipedia.org/wiki/Disruptive_innovation">disruptive innovation</a>
resulting from ubiquitous high speed internet to the home which has technically enabled OTT to take off.
Until very recently, for the past 25+ years the legacy CA pay TV operators,
who owned the physical cable and satellite infrastructure, had a "license to print money".
Nearly every household had a CA pay TV subscription.
For example, the US DirecTV's CA service has a subscription fee $50-125/month, plus $5 per video-on-demand view.
But today (2017) a US Netflix subscription fee is only $10/month with a bank of over 4K movies.
Industry data from Q1-2017 shows that hundreds of thousands of CA subscribers are "cutting the cord" per month,
while Netflix has reached 100M subscribers worldwide!
<p>
I had been working in the industry that provided the CA operators with their security infrastructure,
namely the smart cards that are inserted into the CA set-top boxes.
"Fortunately" for the past 25+ years the cost of the pay TV subscriptions were so
high, that there was a significant illegal market for counterfeit smart cards.
Therefore the operators required that their smart cards be regularly
replaced every 2-3 years in order to stay one step ahead of the hackers -
otherwise the counterfeiters could cut deeply into their profits.
Therefore the pay TV "protection" industry collectively sold the CA operators tens
of millions of smart cards per month which generated huge profits.
From the perspectives of the smart card suppliers, they had found themselves in the center
of the "perfect economic storm", but in a positive sense, that generated endless profits.
But their cataclysmic economic "Ice age" has arrived.
With the new phenomenon of "cord cutting", smart card sales are plumeting.
And their profit per OTT license, that they also sell to the operators, is barely
10% of what they make per smart card.
<p>
For the past 10 years, the security companies were already aware that they could
sell their own OTT service directly to subscribers, just like Netflix does.
However they did not want to antagonize their major customers, the CA operators,
by directly competing with them because they were still buying millions of smart cards per month.
Today they are finally willing to enter the OTT market, even if it means competing against the network operators,
except for the fact that they recognize that Netflix has a 10 year head start.
Most significantly, Netflix knows how to service tens of millions of subscribers,
both from the perspective of network operations and from the perspective of customer service.
Up until now, typically individual smart card supplier companies had a
few tens of business customers who were the CA operators.
They don't <i>yet</i> have the technical know-how or the corporate culture to
ramp up to servicing millions or tens of millions of consumer subscribers.
Therefore unless they quickly acquire this know-how, or merge with a company who has it,
then their long term prognosis is not good.

<h4 tabindex="0" id="2.2.1">2.2.1 TVaaS (TV as a Service)</h4>
<p>
On the other hand, my former employer Viaccess-Orca has a developed a new niche market pay TV product,
<a href="http://www.viaccess-orca.com/tv-as-a-service">TVaaS (TV as a Service)</a>,
that relies upon their existing "Secure Player" OTT infrastructure.
TVaaS provides the infrastructure that enables any business to become their own private OTT operator.
To the best of my knowledge, no other company has yet entered this niche.
The following are 3 example usage scenarios:
<ol>
<li>A small movie production studio wants to distribute on their own a DRM protected
movie on a pay-per-view basis without having to negotiate with Netflix or any other operator to become their distributor.
They could even place the trailer for free on You Tube.
This is by far the most profitable way for a small studio to maximize their royalties.
It is similar to self-publishing a book on Amazon/Kindle.
</li>
<li>A small sports channel that specializes in a niche market, e.g. UK cricket,
wants to market their own channel without having to negotiate with ESPN to become their distributor.
</li>
<li>A company that offers a video course, wants to restrict viewing only to those who have subscribed to the course.
</li>
</ol>
Since the content is DRM protected with Viacess-Orca's own proprietary DRM then
in order to view the content, a subscriber first needs to download the TVaaS
player to his device, and secondly to execute a one time registration process.
Afterwards the subscriber can see any content on the channels for which he is registered.
It is very important to note because the content is DRM protected,
it will be very difficult for an authorized viewer to make a pirate copy of the content.
<p>
As of Q2-2017, this product is still brand new.
It remains to be seen whether or not it will achieve achieve sufficient market traction
- enough to make a difference to replace the loss of revenue from smart card sales.
</details>

<h3 tabindex="0" id="2.3">2.3 Work Experience at Cisco-NDS</h3>
<p>
<details>
<summary>Beginning 2004, my last 5 years at NDS, I was a security researcher and involved in business development.
<br>The following is the list of the varied tasks that I did at NDS:
<br><span class="readmore"/>
</summary>
<ol>

<li>My regular background task was to do code security reviews.
At the most basic level, this involved enforcing the use of textbook
<a href="https://www.securecoding.cert.org/confluence/display/seccode/Top+10+Secure+Coding+Practices">safe programming practices</a>
such as protecting against "stack smashing", wiping memory before freeing it, validating user data, etc.
At a higher level, it involved checking how well the secrets/keys and program flow were protected
against <a href="https://en.wikipedia.org/wiki/Reverse_engineering">reverse engineering</a>
- both static and dynamic.
<p></li>

<li>We came to the conclusion that it was far too difficult for the average programmer to be concerned about both producing correct code,
and simultaneously to protect it against reverse engineering.
Therefore I was part of the specification team for an <a href="https://en.wikipedia.org/wiki/Obfuscation_(software)">obfuscating</a> compiler
to be implemented using the open source <a href="https://en.wikipedia.org/wiki/LLVM">LLVM</a> compiler infrastructure.
The fundamental design principle of the LLVM compiler is that its first translation phase produces virtual object code,
known as IR (intermediate representation).
Afterwards it has a number of optimization phases which it applies to the IR code.
The final translation phase invokes a backend that converts the IR to target object code, e.g. ARM or X86.
So our concept was to replace the optimization phase with an obfuscation phase -
which allowed us to take complete advantage of the rest of their very extensive infrastructure.
Eventually, after I left the company, this became their internal "chameleon" compiler which was incorporated into many of the company's products.
Note that besides the fact we found the LLVM architecture better suited to our purposes than (at the time) the more popular <a href="https://gcc.gnu.org/">gcc</a> compiler infrastructure, the gcc licensing was far too restrictive.
<br>Postscript 2017:
<ul>
<li>There is a very high cost of building an industrial strength product like this one in-house.
I would estimate a bare minimum of 5 man years,
 of course after being able to recruit a pair of programmers who understand what it means to write a compiler.
After I left the company when I required an obfuscating compiler for other projects,
I found 2 commercial obfuscating compilers that are based upon the LLVM architecture.
The best one is <a href="https://www.whitecryption.com">WhiteCryption SCP</a>.
Even though at first glance it seems very expensive,
if you factor in the true costs of "rolling your own", then purchashing their product usually makes economic sense.
</li>
<li>
The GCC <a href="http://gcc-melt.org/">MELT</a> extension project seems to be a technically promising alternative to LLVM, but its license is impossibly restrictive for a proprietary commercial application.
<p></li>
</ul>

<p></li>

<li>I gave technical and logistic support (e.g. creating false identities) to the operational security team whose job was to infiltrate
<a href="https://en.wikipedia.org/wiki/Card_sharing">smart card sharing</a> groups which is the "Achilles' heel" of
<a href="https://en.wikipedia.org/wiki/Conditional_access">conditional access (CA)</a> pay TV technology. The cable and satellite pay TV operators found it too difficult and too expensive to force their subscribers to upgrade their old "legacy" set-top boxes with more modern and secure ones.
Card sharing groups would use these legacy set-top boxes to bypass the CA security mechanisms.
<p></li>

<li>I was the technical lead and the main writer of a proposal to China CCC TV to protect their TV broadcasts of the 2008 Beijing Olympic games.
As the host country, the IOC allowed China to have a free internal TV feed.
But to the rest of the world this feed was worth billions of dollars in royalty payments.
If the Chinese were not able to implement a mechanism to make sure that their internal IPTV and satellite broadcasts would not be leaked outside
of their country then they were warned that the owner of the feed, NBC, would demand that they be cut off immediately.
Due to the high political profile that the Chinese government placed on the games,
it would be intolerable to have their feed cut off.
Ironically I worked on a project in 2006 to protect the World Cup Football (FIFA "Mondial")
broadcasts where the biggest pirates were from inside China.
I provided the Chinese with a very detailed technical analysis of how I intended to secure their feed.
I very frankly mentioned how I had extensively researched how the <a href="https://en.wikipedia.org/wiki/Great_Firewall">Great Firewall of China</a> had been
successfully breached, and how I could use this knowledge to protect the feed.
I also very frankly mentioned the corner cases of my protection techniques where I would not be able to detect leaks,
e.g. on the border between Hong Kong and Shenzhen.
The Chinese greatly appreciated my brutal honesty. The only company competing with us was Microsoft.
CCC TV was intending to use an array of 10K Microsoft servers with illegal licenses,
and at the time almost all PCs in China had illegal copies of XP.
Therefore CCC TV was extremely reluctant to allow Microsoft to install software on virtually every single PC in China.
At the time NBC had merged with Microsoft, i.e. MSNBC. Microsoft found it intolerable that they would not be part of this huge project,
so they agreed not to complain about the illegal licenses, and they offered to do the installations for free,
whereas NDS had intended to charge about $0.25 per PC/TV device. We estimated that there were at least 100M devices.
Bottom line, CCC TV rejected our proposal.
<p></li>

<li>I wrote a business development proposal to enter into the game protection industry. The economic justification for this proposal was that premium games are relatively expensive, e.g. $75. Their production costs of the game studios are similar to movies. Their initial release generates more revenue than blockbuster movies, but their security protection schemes are typically hacked within the first month. A better protection scheme could buy the studios an extra month or two of protection which could provide them with an extra $50M in revenues.
<p></li>

<li>I wrote a business development proposal to enter into the ink cartridge protection industry. Bubble jet printers are marketed using the wildly successful Gillette razor and blades business model that Mr. Gillette invented over 100 years ago. You sell a high quality razor holder at cost, while making long term lucrative profits from the consumables, i.e. the safety razor blades. Bubble jet printers are typically sold at cost, while the manufactures make lucrative profits on the ink cartridges. By weight, the price that many manufactures are able to sell their ink is more expensive than gold! Their problem is the competition from the much less expensive clones of their ink cartridges. Therefore a cartridge interface is required that is very difficult to clone/counterfeit. (As a result of my analysis, personally I own a black and white laser printer. They are much less expensive to operate in the long run. And it is much less expensive to go to a photo shop to print a color photo than to print one with a bubble jet color printer. This is an especially expensive problem in K-12 schools, where students have unmonitored access to printers which they use for printing photos).
<p></li>

<li>I gave a presentation to senior management,
in conjunction with the head of the QA department,
about the huge development costs associated with fixing bugs.
Nearly 25% of their R&amp;D manpower were devoted to fixing bugs!
I discovered the extent of these costs by "data mining" their ClearQuest bug tracking database.
And I also suggested numerous relatively easy to implement <a href="#software-quality">techniques</a>
(<i>in section 2.6.1 which you may have to scroll down into manually due to HTML limitations</i>)
that would greatly reduce the number of bugs.
<p></li>

<li>I became an expert in the use of Virtual Machine (VM) technology, particularly the QEMU emulator,
to show how I could analyze and crack their state-of-the-art cryptography.
My favorite technique was to break their Pseudo Random Number Generator (PRNG) engine
by attacking the X86_64 <a href="https://en.wikipedia.org/wiki/Time_Stamp_Counter">RDTSC</a>
assembly instruction which reads the number of clock cycles accumulated by all of the instructions since the CPU booted.
Once I was able to subvert the RDTSC instruction, I induced the PRNG to generate a <i>deterministic</i>
<a href="https://en.wikipedia.org/wiki/Cryptographic_nonce">nonce</a>
which is the initial step in all cryptographic handshakes.
Note that a deterministic nonce is a cryptographic oxymoron.
It allowed me to break their cryptographic handshake.
And it allowed me to replay the nonce in order to share a single license authorization key among many confederate subscribers.
<br>Postscript 2017:
<ul>
<li>Until 2014, RDTSC was the fastest, easiest, and thus most commonly used source of 64-bit entropy/randomness on the X86_64
architechture. Subsequently on new CPUs the <a href="https://en.wikipedia.org/wiki/RdRand">RDRAND</a> instruction is a much better source.
But it is still possible to subvert RDRAND too.
</li>
<li>Note that the subversion process was <i>selective</i>. We had the option instead of subverting RDTSC across the board for all processes,
or we could decide to subvert it just when a specified process was calling the instruction.
That way if someone were running a RDTSC test program, or another app that relied upon RDTSC then the apps would generate the correct/expected results.
Still it is true that if the defender already suspected that we were tampering with the RDTSC instruction,
then by adding debug code he could detect our tampering.
</li>
</ul>

<p></li>

<li>I used the ubiquitous VirtualBox VM manager to provide simple recipes for breaking the Microsoft PlayReady DRM licensing schemes.
<p></li>

<li>I organized a 2 day seminar with a famous security researcher, <a href="https://en.wikipedia.org/wiki/Joanna_Rutkowska">Joanna Rutkowska</a> who specializes in the use of VMs.
<p></li>

<li>I organized a week long seminar on reverse engineering techniques, to which I invited a famous hacker (Kaspersky, but not the head of security company with the same name) to be the lecturer. The seminar was well-attended, and extremely successful.
<p></li>


<li>I wrote an article describing cryptographic side channel attacks. The example I used was how to write a safe string compare function.
<p></li>

<li>I wrote a prototype device driver for a PC that showed how a USB smart card that permitted the playback of up to 3 movies could be remotely shared by multiple computers. (Today, in 2017, there are open source and commercial USB over TCP/IP drivers/applications).
<p></li>

<li>I wrote a specification for a PC that could be used both as a secure CA set-top box (STB),
and as a regular PC.
The economic justification for this box was to keep the subscriber's eyes glued to a single box.
For example a subscriber could view his email while watching a movie without having to change devices.
In order to secure the STB, I selected a consumer X86 CPU that had a "trusted execution environment".
<p></li>


<li>I gave a seminar on advance TCL programming.
 The company used TCL extensively for their smart card H/W verification systems.
<p></li>

<li>
I gave a presentation to the "offline tool utility department" on the philosophy
and benefits of developing a software toolbox with lots of small gadgets and filters,
i.e. the Posix way, instead of writing huge monolithic tools.
<p></li>

<li>2003: I built a hybrid simulator/emulator of a commonly used legacy TV STB (set-top box) that
originally had no debug capabilities other than writing "printf" statements to the console.
I completely reverse engineered the OpenTV middleware API so the calls could execute on a PC,
and used RPC (Remote Procedure Calls) to access the hardware specific API calls that had to run on
the STB. This emulator allowed all of an application's code to be run "as is" on a PC from within the
Microsoft VisualC debugger, while still displaying the true results on the TV set connected to the
STB.
The project was a major success.
<p></li>

<li>1999: I was the architect of an automated test system for a satellite communication system.
 I designed a domain specific language (DSL) to describe and to simulate a satellite communication
 protocol which was passed to their back-end Win32 server as if it came directly from the satellite.
 The system architect assumed that a tester was by definition a second class programmer, i.e. an Orwellian 1984 "beta".
 After doing an in-depth study of his architecture, I warned him of a major flaw in his design, but of course he ignored me.
 So I wrote a straightforward test that crashed his server even though it only used less than 25% of the satellite's capacity.
 Afterwards he readily agreed that I provide all of his programmers with a sanity testing application written in the DSL
 that they would execute on their PCs before checking in a build.
 The test application also allowed the programmers to write custom unit test scripts for new features that they were implementing.
 The project was a major success.
</li>

</ol>
</details>

<h3 tabindex="0" id="2.4">2.4 Significant Prior Work Experience Unrelated To Security</h3>
<p>
<details>
<summary>
Previously I was involved in the architecture of successful state-of-the-art projects in other application domains,
such as bioinformatics, accessibility, communications, VLSI CPU design, shop floor production control system, automated vehicle navigation, etc.
I quickly learned to become an expert in these fields.
I am an innovative "out-of-the-box" thinker.
I am an <a href="http://99u.com/articles/7269/picasso-kepler-and-the-benefits-of-being-an-expert-generalist">expert generalist</a>, and I am an
<a href="http://autodidactpolymath.com/autodidact-polymath-definition/">autodidact polymath</a>&nbsp;<sup><a href="#polymath-footnote">4</a></sup>
(= self-taught who has achieved expertise in many domains).
I am able to "synthesize" my knowledge.
I am often able to apply the skills and knowledge that I acquired in one domain, and successfully apply them to another. To get to this level of expertise so quickly, I also needed to rely upon experts who mentored me. In return, I have mentored many others. The following are details of selected projects.
<br><span class="readmore"/>
</summary>

<h4 tabindex="0" id="2.4.1">2.4.1 2010: Bioinformatics: Discovered New PCR Algorithm: Consultant @Syntezza Jerusalem</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
Within 3 months of entering the field of <a href="https://en.wikipedia.org/wiki/Bioinformatics">bioinformatics</a>,
I discovered a new more accurate
<a href="https://en.wikipedia.org/wiki/Polymerase_chain_reaction">PCR (DNA amplification)</a>
Ct prediction algorithm that worked particularly well in noisy environments due to
<a href="https://en.wikipedia.org/wiki/Polymerase_chain_reaction_inhibitors">PCR inhibition</a>
usually as a result of poor sample preparation techniques,
or where the process was intentionally stopped too soon for commercial reasons
in order to prove to customers and investors how much faster the new system is compared to the competition.
I was working for a company developing a new <i>dry</i> MRSA detection kit,
where MRSA<sup><a href="#mrsa-footnote">5</a></sup>
is a deadly strain of antibiotic resistant staphylococcus bacteria that thrives in hospitals,
and is the number one cause of fatal infections in hospitals.
When I arrived their kit was failing. Its detection rate was 50%, and as a result the company was facing liquidation because the investors were losing confidence.
Within 3 months I raised their detection rate to 95+% (!) which was about 10% higher than the detection rate of their competitors - mainly from the giant multinational pharmaceutical companies. Before beginning this project, I had zero background in bioinformatics, biology, or biochemistry.
<p>
The classic PCR Ct prediction algorithm invented by
<a href="https://scholar.google.de/citations?user=XokRoVQAAAAJ&hl=de">Tzachi Bar</a>
assumes that the underlying function being estimated is a flat "S" curve typical of biological assays,
formally referred to as a
<a href="https://en.wikipedia.org/wiki/Logistic_function">logistic function</a>.
My mentor was in fact Bar, who got me up to speed very quickly.
After noticing bizarre results from pure MRSA samples from laboratory colonies (i.e. and not patient samples),
simply by carefully reading the <a href="https://en.wikipedia.org/wiki/Thermal_cycler">thermo cycler</a> manual,
I noted egregious mistakes in the experimental protocols on which they spent $500K.
They had placed the test tubes with the negative and positive control samples,
required for every batch, in the wrong positions in the thermo cycler!
But having had access to the original raw data from the thermo cycler, I was able to correct these mistakes.
Even after having made these corrections,
I still noted that the Bar algorithm produced results with an R^2=99% where the underlying data was
a nearly perfectly straight line or random noise
- certainly nothing like the flat "S" shape that the algorithm expected.
This was due to a conceptual flaw in how the
<a href="https://en.wikipedia.org/wiki/Levenberg%E2%80%93Marquardt_algorithm">Levenberg-Marquardt (LM)</a>
transcendental function estimation algorithm is applied.
The example that I am fond of using is when giving the LM algorithm a functional
description of a bactrian (2 hump) camel, it will prove with an R^2=99% that a horse
with 2 warts on its back is indeed a camel.
<p>
During this short period I made some important discoveries:
<ol>
<li>I discovered a much more powerful and much simpler algorithm to normalize data,
and to reduce noise - compared to the Bar algorithm.</li>
<li>I discovered an alternative AI (artificial intelligence) based algorithm that
very accurately determined whether a sample is positive or negative
(according to the Petri dish results)
when the underlying data did not exhibit the flat "S" shape expected by the Bar algorithm.</li>
</ol>
<p>
I am in the process of patenting my algorithm.
</details>

<h4 tabindex="0" id="2.4.2">2.4.2: 2002: Blind Accessibility: "See" Digital Images on a Computer Display: CTO @Virtouch Jerusalem</h4>
<p>
<details>
<summary>
<figure>
<img title="Virtouch VTPlayer tactile mouse" alt="Virtouch VTPlayer tactile mouse" src="http://purl.org/Avraham.Bernstein/resources/vtplayer.png" />
<figcaption>VirTouch VTPlayer tactile mouse. Note the two finger pads on the back, each with an array of 4x4 refreshable braille pins.</figcaption>
</figure>
<br><span class="readmore"/>
</summary>
Within a year of entering the field enabling the blind to "see" (i.e. comprehend)
digital images, e.g. geographical maps and mathematical functions and even randomly encountered images,
I discovered a very successful and inexpensive technique for enabling the blind to "see" these images
by using the computer's built-in sound card, and by using an off-the-shelf graphics tablet or the touch
screen on a smartphone or tablet.
<p>
It was very difficult for the founder of the company, Dr. Roman Gouzman, who was financially forced to
accept new management, to detach himself from the tactile mouse hardware that he patented, see photo above.
The mouse was way too expensive for our target audience, ~$400. Consequently the company was sliding into bankruptcy.
<p>
In default mode, the mouse converted
the pixels on the screen to an 8 bit gray level. The default
threshold was 64 (out of maximum possible value of 256),
so when the gray level was above the threshold the pin over the
pixel was up, and <i>vice versa</i>. At any given position on the
screen (except the edges) its 32 pins would provide pixel color feedback.
Therefore a user could scan a particular region of the screen
and feel the pixels. Given that a screen has millions of pixels,
and the cost of each pin was about $2, having a big tablet with thousands
of pins was financially unfeasible. The tactile mouse provided a virtual window
into a tablet with millions of pins.
<p>
The problem with the default solution was it was very easy for a blind user to
scroll off the edge of the screen since they cannot see that the cursor is stuck
at the edge position where it scrolled off. Therefore I added
audio cues and a vibrating pin pattern to indicate where
the user scrolled off. Afterwards I added a background grid
with audio pips to indicate when the mouse changed its grid
position, where the tone of the pip indicated the new grid
position. In spite of my improvements, blind people don't
like mice, and anyway the hardware was too expensive.
<p>
So I abandoned the mouse entirely, and instead used the computer's built-in
sound card combined with an off-the-shelf graphics tablet and stylus.
It was a much less expensive solution, and an outstanding success
because blind users can naturally spatially navigate a graphics tablet.
They know precisely where they are on the tablet. And by using an SVG
color pallet overlay on the screen, I could easily translate color to
screen position. By using 2 instruments, say piano and flute,
each playing a "major" scale with a range of 8 octaves,
we created a sonic grid of 64x64 tone combinations that indicated
precisely in which one of 56x56 grid positions (note a scale has 7 notes) on the screen the stylus was currently located.
Also the sensory acuity of the human ear provides 100-1000 times more bits of information than the fingertips.
<p>
My big conceptual breakthrough was using XML/SVG to describe the graphics objects
on the screen, so I could give them context or semantic meaning.
I started with MapML which is a very common language for describing digital maps.
Therefore I could easily remove map clutter by allowing the user to filter/select
just the map layers that he wants - for examples just cities and major roads,
which is a built-in MapML facility. Or we could display a topographic map,
and allow the user to select the resolution of the isolines, e.g. every 500 meters.
At every mouse position XML/SVG automatically returned the context at the cursor
position which we "conveyed" to the user via text-to-speech. Or we could change
the pitch or volume of a audio pip when the user touched a city with a large population
versus one with a small population. Etcetera.
<p>
SVG has seamless zooming capabilities, so it was trivial for the user to zoom-in
or zoom-out at his cursor position.
<p>
Most graphics cards support multiple screen layers - at least 2. So we could instantaneously
switch the query from the MapML layer to the SVG color grid used for audio spatial feedback.
<p>
One of the most difficult subjects for the blind to learn is mathematics, e.g.
functional analysis and geometry, because they are inherently visual. Using SVG
we could allow blind users to visualize these mathematical objects and
relationships. We could allow a user to change a function's parameters, and to
"see" the new results, or we could automatically change one or two parameters at
some predefined speed, and allow the user to "see" the results change.
<p>
The main purpose of my work at Virtouch was to to provide tools for adult
computer users. Up until I came, Gouzman's focus had been on using the mouse to help
blind children. Most government agencies have limited budgets for helping blind
children, but they had very large budgets for providing the blind with tools
that will allow them to enter the workforce - in order to keep them gainfully
employed and off of public assistance. I wrote a proposal to the European FP6 Research Framework
(administered locally by Israeli government chief scientist). They awarded me
a 0.5 million &euro; matching grant. Unfortunately the investors had heard too
many unfulfilled promises from Virtouch management, so they liquidated the company,
instead of putting up their half of the grant money.

<h5 tabindex="0">Lessons Learned</h5>
<p>
The most important lesson that I learned from this project is that it usually
impossible to make a profit if a custom piece of accessibility hardware is necessary to implement
a concept. Given the extremely small volume of sales, production costs are exorbitant.
Therefore it is critical to use or re-purpose off-the-shelf hardware.
<p>I have had other discussions, sometimes with government agencies and NGOs, who are tasked with
helping the blind. Typically their first suggestion is to build a new piece of hardware,
or to force the government to pass an accessibility law. Whereas I try to find
lo-tech solutions that are useful not just for disabled people.
<p>Example 1: Most governments would like to provide an (inexpensive) solution
for the blind to navigate public transit systems. But thinking a little bit
more broadly, most public transit systems can only provide signage in at most
2-3 languages, which is a big problem in cities that host many tourists. Therefore
my solution is to place a bluetooth beacon in every public transit coach.
These beacons are very inexpensive. Each beacon has a universally unique ID. They have a
range from 50-500 meters depending upon their signal strength and local RF conditions.
All smartphones are able to identify these beacons. Let's say there were a database of all beacons
per geographic region that could filter the type of beacon in which the user
is interested, e.g. public transit, and that could redirect the user to the web
site associated with the beacon. If the web site were designed intelligently then it should have the
ability to support blind users, along with support for a host of foreign languages.
<p>Example 2: Many governments and NGOs would like to insist upon legislation that all government web sites,
and web sites of large enterprises must provide an interface for those who are
visually challenged. I completely disagree. Most large websites today are engineered
with an underlying XML schema which is used to define every page in their site.
The XML schema describes the logical design of a web page, independent of how it
is visually presented. There are already lots of off-the-shelf "mash-up" software
packages available that allows a user to take advantage of these schemas in order
to present the information on the page specifically the way the user wants - for
example combining multiple web sites into a single page.
Therefore there could be a user group for visually challenged people who like
to read the on-line version of the Jerusalem Post newspaper. Many of the users
in this group will have already created their own presentation layer that makes reading
this newspaper more convenient for them. And their could be country specific web sites run by
NGOs (e.g. NFB, ACB, RNIB, CNIB, Perkins, etc.) and universities that provides a common library of techniques.
It would be a worthwhile project to facilitate the development of such a "crowd sourcing" infrastructure.


</details>

<h4 tabindex="0" id="2.4.3">2.4.3: 2015: Dyslexic Children Accessibility: Dyslexic Font Design Concept: Personal Project</h4>
<p>
<details>
<summary>
<figure>
<img title="Dyslexic font" alt="Dsylexic font" src="http://purl.org/Avraham.Bernstein/resources/dyslexic.png" />
<figcaption>Dyslexic font. Note the small bar in the middle of the far left column.</figcaption>
</figure>
<br><span class="readmore"/>
</summary>
I also have a major interest in special education, partly because one of my grandchildren
has a learning disability, and partly because my daughter-in-law's mother,
Dr. Esther Perl Ranells, is the head of the special education department at
the Michlala Jerusalem teacher's college in Bayit Vegan.
If I could afford it, I would choose special Ed to be my next profession. I developed a font for dyslexic children,
based upon the principle of QR code orientation. Note that all QR codes have 3 relatively large black
orientation squares, i.e. in the NW, NE, and SW corners, while there is no orientation square in the SE corner.
<figure>
<img title="QR code" alt="QR code" src="http://purl.org/Avraham.Bernstein/resources/AvrahamBernstein-QR.png" />
<figcaption>QR code. Note there are orientation squares in only 3 of the corners.</figcaption>
</figure>
Therefore it is trivial for the scanning program to rotate the QR code into the proper orientation position.
<p>
Now consider the custom dyslexic font above where there is a small bar in the middle of the far left column.
Therefore a child has to remember only a single rule when examining an individual letter,
namely that it is correctly oriented if and only if there is a small bar the middle of the far left column.
The flaw in this scheme is that when a string of letters are attached together to form a word,
almost no one can discern whether the middle letters have the bar on the left or the right side. [TBD: Show example].
However one solution is to make the standard fonts more narrow so the dot will not be so close to the edge, but which probably cannot be done automatically,
and therefore would require too much manual art work to rework the standard fonts.
The alternative trivial solution is to automatically edit the text in a document by simply inserting a blank space between each letter.
<p>
I still have not yet created the software environment to test this scheme out on dyslexic children,
although it would be a good project for me to mentor at the teacher's college.
And whoever implements the project would be able to make a thesis out of it - certainly a master's thesis, and perhaps a doctorate.
</details>

<h4 tabindex="0" id="2.4.4">2.4.4: 1988: Quadriplegic Accessibility: Consultant @Cubital - a subsidiary of @Scitex Herzliya Pituach</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
I was the software architect of a system that enabled <a href="https://en.wikipedia.org/wiki/Tetraplegia">quadriplegics</a>
to access computers with CRT video displays <i>before the era of inexpensive voice recognition technology, tablets, and smartphones</i>.
<p>
The hardware we used for this project was a standard <a href="https://en.wikipedia.org/wiki/Light_pen">light-pen</a>
(an obsolete point-and-select input device that determines its position via the CRT's scan point)
combined with custom telescopic optics that extended its normal maximum range to the screen from 10 mm to 800 mm,
which we attached to the user's head with a headband, along with a standard accessibility
<a href="https://en.wikipedia.org/wiki/Sip-and-puff">sip-and-puff</a> switch.
<p>
The software had 2 modes of operation.
In learning mode, a virtual keyboard covered about 80% of the screen.
When the light-pen was aimed at a key then it would be illuminated.
Puffing on an illuminated key caused the virtual key stroke to be entered into the operating system.
In normal mode, the virtual keyboard was no longer visible.
Instead a single key would pop up at the position on the underlying hidden virtual keyboard where the light pen was aimed,
leaving 95% of the screen real estate available for the "real" application.
<p>
This system enabled our first client, Shulamit Gabai, a former school teacher who was stricken with polio in all of her limbs,
to type 30 characters per minute, and to become a book editor for a major publishing house.
</details>

<h4 tabindex="0" id="2.4.5">2.4.5: 1989: "Talmudic Brainstorming": How I Turn Dreams Into Reality: Architect @DEC Herzliya Pituach &amp; @Iskar Tefen</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
I typically work on projects that are new and highly innovative.
Often in the beginning, the concept is nebulous - so it is extremely difficult to formally specify.
During this preliminary design stage, first we must specify our goals in details, and to categorize and prioritize them.
Secondly we have to come up with a model for an architectural implementation. This process is iterative. It may take days or weeks or even months to refine it.
Whenever we change the implementation model, which we do very frequently in the beginning, features that I didn't believe were possible before, now become possible, and <i>vice versa</i>.
Frequently a discussion will begin with the phrase, "let's pretend/assume that certain prerequisite conditions were true, then what could we achieve?",
even though at the moment we feel that these prerequisite conditions do not yet exist, but we have a gut feeling that they could possibly exist at some time in the not too distant future.
<p>
This process requires mental agility, flexibility, and malleability. It requires creativity and visualization skills.
I find it best to engage in this mental process with a single partner, who must be capable of this same type of malleable thought process,
who can play the role of "devil's advocate", and who can ask penetrating questions in order to always carefully test that the new model continues to meet its goals,
and even to question the validity of the goals.
I will refer to this process as "Talmudic brainstorming". It is a particular style of guided "brain storming" which I feel is suite to extremely small groups.
I've never formally described this mental process before, but in my opinion it is similar to the way Jews have studied Talmud for the past 2500 years.
<p>
The first time I "discovered" this Talmudic brainstorming process was in 1988 when DEC hired me, along with my co-architect and still close friend David Goldstein, to develop a software architecture for automatically operating/orchestrating a hi-tech factory, the Iskar Matkash Cutting Tool factory in Tefen Israel.
The software is formally referred to as a shop floor production control (SFPC) system.
Tefen makes thousands of different cutting blades using a <a href="https://en.wikipedia.org/wiki/Sintering">sintering</a> process.
The raw materials go through many stages of operations.
In many cases after undergoing intermediate processing, the partially processed material could still be diverted to multiple final products
- similar to stem cells.
The factory contains hundreds of automated workstations, stands, stacks, guided vehicles, and conveyor belts.
Pallets can be automatically move from one stand on a workstation to the next,
or to temporarily place a pallet on a storage stand or a stack stand.
<p>
<i>In the beginning, we had no clue how to proceed!</i>
I recall that we visited the factory only once at the very beginning of the project.
At our disposal, we had an industrial engineer, Motti, who mentored us, who kept us grounded about what this factory was physically capable of doing.
In the beginning, the industrial engineer wasn't very computer savvy, and we were not very savvy about industrial engineering, but with each others help we quickly filled in the gaps.
Eventually after a few months of daily discussions we created an architecture that was a textbook object oriented taxonomy - a "factory object kingdom".
I was the author of the domain specific language (DSL) manual that described each class of object in the factory down to its minute details,
i.e. its attributes and methods.
We called this language BARI (<i>Baqarat Ritzpat HaYeTzur</i>) which is the Hebrew acronym for SFPC (shop floor production control).
The language was designed to be understood by the factory engineer, even though most operations could be done with a GUI which generated factory script.
In order to keep the language simple for the factory engineer, the language was "descriptive" as opposed to "procedural".
We implemented the system by mapping the language to a large relational database with 100+ tables, and many indices.
This database mapping was in itself a major technical challenge in order to do it correctly and efficiently
- considering that none of us came to the project with any prior relational database experience.
Afterwards we worked with a team of 4 additional programmers to implement the BARI command language in the Pascal programming language.
Our, i.e. the architects', first choice language was C++ because of its built-in object oriented functionality.
The language had already become industrial strength at least 5 years earlier.
But DEC's technical representative on the project only knew Pascal, and wasn't willing to learn a new one.
Since DEC wrote the checks, we learned Pascal, and became proficient within a week or two.
We developed our own object oriented like programming paradigm,
similar to what the X Motif and the gLibc projects did using "C" - and <i>not</i> C++.
Within 2 years from the beginning of the project,
we completed the software, and the factory worked perfectly!

<h5 tabindex="0">Musings about why the language, the culture, and the education process in the Far East inhibit creativity</h5>
<p>
This leads me to answer a question that I've heard asked a number of times by the Chinese and the Koreans.
The home of my friend and neighbor <a href="http://www.refuah.net/">Rabbi Dr. Joshua Ritchie</a> has become a beachhead for many Chinese (PRC) visitors to Israel.
They regularly ask him why is it that the Jews, who are such a tiny people, ~12M, have been so successful in receiving Nobel prizes so greatly out of proportion to their small numbers, and why is that the tiny modern State of Israel, with ~6.5M Jews, has become the world's hi-tech powerhouse? I do not find that they ask the question out of jealousy, but rather because it is an enigma that never ceases to astonish them.

<ol>

<li>There is an ancient Jewish tradition that encourages people to ask questions, including questioning core assumptions and beliefs.
The younger the questioner is, the more the one being asked is tolerant of answering the most outrageous questions - many times which are in fact very deep and penetrating.
Young Talmudic students, young soldiers, and junior employees in hi-tech are encouraged to ask their superiors (even many ranks above them) hard questions, and within reason to expect to receive a considered response. In other cultures, this type of questioning will never happen because it is considered to be grossly disrespectful (Hebrew/Yiddish: <i>Hutzpa</i>).</li>

<li>One can't play this Talmudic brainstorming "game" without asking such questions, and of also of course without the capability for a high degree of abstract thinking.</li>

<li>An acquaintance of mine, also in hi-tech, Avraham Ben David of blessed memory, spent considerable time in Japan, and learned the Japanese language.
He noted that the lack of an alphabet forced young school age children to spend their formative years memorizing the meanings and vocalizations of thousand of pictographs in order to become literate.
Whereas young Jewish children learn Hebrew. Hebrew is made up of 22 letters. Very quickly a child learns to combine them into words.
As soon as the child learns to read, he will have a vocabulary of hundreds of words, although he can already phonetically correctly pronounce 99% of the words in the language.
Most Hebrew roots are trilateral, i.e. made up of 3 core letters. From these trilateral root there is a regular system of adding prefixes and suffixes to produce singular and plural noun forms, add pronouns, add prepositions, and to convert the root to the standard 7 verb declensions (Hebrew: <i>Binyanim</i>), each of which has a past and future tense.
Even though young Jewish children who learn Hebrew do not yet <i>formally</i> understand the grammar, most of them have internalized these language <i>abstractions</i> by the time they reach 1st grade. Therefore by naturally mastering the language, which is what young children are neurologically programmed to do, they have already begun to master the art of abstract thinking, while their counterparts in the Far East are spending their formative years memorizing pictographs.</li>

</ol>
</details>

<h4 tabindex="0" id="2.4.6">2.4.6: 1991: VLSI CPU Development Software Toolchain: Owner S/W Outsourcing Company @Pitkha Jerusalem: Client @DSPG Ramat Gan</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
I was the software architect of a clock accurate <a href="https://en.wikipedia.org/wiki/Digital_signal_processor">DSP</a>
CPU simulator along with a complete software development <a href="https://en.wikipedia.org/wiki/Toolchain">toolchain</a>,
i.e. a debugger, C compiler, assembler and linker.
Note that the system was developed just <em>before</em> the <a href="https://gcc.gnu.org/">GNU Compiler Collection</a> framework reached maturity,
i.e. v2.95.

<p>This system enabled <em>working</em> applications to be developed <em>before</em> the chip became physically available.
This system reduced the client's time-to-market by 6-12 months.
The technological breakthrough was my design of a <a href="https://en.wikipedia.org/wiki/Domain-specific_language">domain specific language (DSL)</a>
that described the CPU architecture which automatically generated the source code
for the toolchain that enabled the system to be automatically rebuilt within an hour
in the face of almost daily changes to the VLSI architecture - especially the pipeline.
</details>

<h4 tabindex="0" id="2.4.7">2.4.7: 2010: Urban Traffic Route Guidance: VP R&amp;D @TeleQuest Jerusalem</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
TeleQuest was a startup engaged in the development of a coordinated dynamic route guidance system,
in order to alleviate traffic congestion in large metropolitan areas
- similar to what <a href="https://www.waze.com">Waze</a> now does.
<p>
Simulation experiments on Tokyo traffic showed that at a guided vehicle penetration rate of 50%,
TeleQuest could provide a sustained average travel time reduction of ~50% for guided vehicles
and ~40% for non-guided vehicles.
None of the competing commercial or academic models come close,
because after penetration rates of 15-20% their benefits peak and then started to decline
because their simplistic opportunistic algorithms generate their own secondary traffic jams
of the guided vehicles.
<p>
My job was to architect, develop, and implement algorithms, in conjunction with a team of
transportation scientists and mathematicians,
that were executed in a real-time traffic simulator running on tens of cloud computers,
to be coordinated with GPS equipped smartphones running our S/W on tens of thousands of vehicles.
<p>
Even though it was beyond the scope of my work,
I learned that the single most important factor for improving the flow
of traffic in congested metropolitan areas is to prevent "hunting" for parking spots.
The IBM <a href="https://www.ibm.com/smarterplanet/us/en/smarter_cities/overview/">smarter cities</a> initiative
is working on <a href="https://www-01.ibm.com/common/ssi/cgi-bin/ssialias?htmlfid=GVS03037USEN">smarter parking</a> systems.
</details>

<h4 tabindex="0" id="2.4.8">2.4.8: 2016: Cybersecurity Protection of a Small Business with Extremely High Security Concerns</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
I worked with a small secretive commercial company, with approximately 15 employees,
engaged in a legitimate business, whose web site was under constant attack,
and whose employees could potentially face physical harm if they were "outed".
The following were the results of my risk analysis:
<ol>
<li>The majority of the employees were researchers who had little knowledge of cybersecurity.
<li>Even the straightforward/naive way that they accessed the Internet could leave tracks that could expose them
provided that their adversary were a well financed technically adept opponent - perhaps with foreign government backing.
<li>They used a WordPress web site on a private server <i>without</i> two factor authentication protection (2FA).
<li>A lot of employees worked from home, or from public Internet hot spots.
<li>They all used gmail, and most <i>without</i> 2FA.
<li>And even those who did use 2FA, used their phone number - so if their phone were lost or compromised then the extra factor wasn't very useful.
<li>Their network file system was Google Drive for business.
<li>They used Windows 7 laptops.
<li>Most had Android phones. None of their devices were configured securely.
<li>A single compromised device, or the theft or loss of a single device, could lead to complete penetration of their network.
<li>The picture could not be much more bleak.
</li>
</ol>
<p>
In order to minimize organizational resistance to change,
I designed a road to security that was a process of very small increments.</details>

<h4 tabindex="0" id="2.4.9">2.4.9: 2010: Transparent Technical Negotiator of Restricted Hi-Tech Trade with China</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
<ul>
<ol>
<li>The Chinese wanted to buy a restricted gyroscope for their super high speed trains from Honeywell that is normally used for <a href="https://en.wikipedia.org/wiki/Intercontinental_ballistic_missile">ICBMs</a>. I proposed to Honeywell that they insert the gyroscope into the center of a tamper proof lead block that weighed say 50-100 kg. For example if the soft membrane surrounding the gyroscope were penetrated with a blade or drill or laser then it would release acid or a binary explosive. Honeywell would be responsible for developing the tamper proof mechanism. They did not have to reveal to the Chinese how they built the mechanism. All they had to do was to give the Chinese a fixed price quote for the custom work. Clearly such a device could not be used on a missile where every extra gram of weight counts, but where the extra weight was of no consequence to the train. Honeywell agreed.</li>
<li>The Chinese wanted to buy the restricted <a href="https://en.wikipedia.org/wiki/Green_Hills_Software">Green Hills real-time operating system</a>. The US government restricts the export of Green Hills <i>source code</i>, but not products that contain Green Hills' <i>binaries</i>. So I asked Green Hills if I could have the <a href="https://en.wikipedia.org/wiki/Board_support_package">board support package</a> developed in Israel which requires access to Green Hills source code, but ship the resulting binaries to China. Green Hills agreed.</li>
<li>The Chinese wanted to buy a drone system from a subsidiary of Israel Aircraft Industries which was designed for commercial/industrial use. The system had <a href="https://en.wikipedia.org/wiki/Intercontinental_ballistic_missile">cruise missile</a> like navigation capabilities with the ability to do <a href="https://en.wikipedia.org/wiki/TERCOM">terrain contour matching</a>. I suggested that they modify their software so that it would not work within 500 km of the Israeli border, along with a back-door jamming channel - due to the fact that it is not uncommon for the Chinese to resell this type of equipment to the Iranians who regularly announce their religious obligation to wipe Israel off the face of the earth.</li>
<li>An Israeli company which develops expensive VLSI design software, e.g. $50-100K per workstation, was afraid that their Chinese agent would cheat them of their royalties. The initial deal was to sell an older version of the software for a one-time flat fee of 20 licenses. The Chinese dealer would be allowed to sell an unlimited number of licenses. But they would modify the next version of their software to be converted to <a href="https://en.wikipedia.org/wiki/Software_as_a_service">Software as a Service (SaaS)</a> in the "cloud" on servers which they would control so that the software could be executed but not copied or downloaded.
</li>
</ol>
</details>

<h4 tabindex="0" id="2.4.10">2.4.10: 2012: CTO of a US Agricultural Trading Company with Nigeria</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
My job was to find hi-tech products that my company needed to purchase,
or that I felt would be worthwhile for them to purchase. I would go to the
annual Israel Agritech exhibition, considered to the be the best in the world, to hunt for products and ideas.
For example:

<ol>
<li>Portable field hospitals and inexpensive quick-to-assemble modular housing units for flood victims.</li>
<li>Inexpensive moisture proof storage bags that can store 500/1000 kg of grain in humid environments with almost no spoilage, whereas previously nearly 75% of the crops placed in field storage facilities were destroyed from moisture induced rot.</li>
<li>Mold resistant produce containers (up to 20 kg) for storage in humid refrigeration facilities in order to extend shelf life.</li>
<li>Bacteria resistant milk cartons for non-refrigerated storage.</li>
<li>Kits to convert SUVs and light trucks to become off-road bush vehicles.</li>
<li>Expert on industrial scale <a href="https://en.wikipedia.org/wiki/Cassava">cassava</a> processing which was formerly the major food staple in Nigeria before they joined <a href="https://en.wikipedia.org/wiki/OPEC">OPEC</a>, and may soon again become their major staple when the oil stops flowing because the government will no longer have the financial resources to subsidize imported wheat.</li>
<li>Establish a private local area GSM cell phone tower with a 10 km radius range in order to support a cassava plantation/factory to be built in a remote jungle location where cassava naturally grows. The factory was well outside the geographic regions supported by the local mobile telephone companies. The efficiency of the plantation would be greatly increased provided that all the workers had mobile phones even if the communications were restricted to the 300 sq. km. region surrounding the factory.</li>
<li>Cement research expert to consult for the largest cement factory in Africa.
</li>
</ol>
</details>

</details>

<h3 tabindex="0" id="2.5">2.5 Algorithms &amp; Source Code</h3>
<details>
<summary><span class="readmore"/></summary>
<p>
I have only just started to populate my new <a href="https://github.com/avraham-bernstein">Github: Avraham-Bernstein</a>
site with some of the more interesting software that I've developed over the years that I am free to publish. My first task
is to create a README.md for each project, and then to upload the source code <i>where it exists</i>.
The following is a list of most of these projects:

<h4 tabindex="0" id="2.5.1">2.5.1 New Nonlinear Cryptographic Primitive: HWDDO (Hamming Weight Data Dependent Operation)</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
I discovered a new class of nonlinear invertible cryptographic primitive which
takes Ron Rivest's original DDR (data dependent rotations) concept into another dimension.
I call this new class of primitive HWDDO, i.e. a Hamming weight data dependent operation.
I discovered a number of different metrics with properties similar to Hamming weights.
The well known critical deficiency of using Hamming weights for cryptographic purposes is their binomial distribution.
Therefore the most important part of my discovery was how to flatten the distribution of these metrics,
and in some cases even to level of being nearly uniform. These HWDDOs can be easily applied
to huge blocks, e.g. 4k bits or 64K bits, and not just the standard CPU architecture 32-bit and 64-bit blocks.
<pre><code>
// 32-bit form

uint32_t f_32(uint32_t x, int w); // HWDDO transformation function which does not change the weight
uint32_t g_32(uint32_t x, int w); // inverse
int w_32(uint32_t x); // weight metric calculation function where 0 <= w < 32

uint32_t x,y;

// f_32(x, w_32(x)) = f_32(y, w_32(y)) ==> x = y
// y = f_32(x,w_32(x)) ==> x = g_32(y,w_32(y)) && w_32(x) = w_32(y)

// general form

uint8_t * f_n(uint8_t * y, const uint8_t * x, int w, int nbytes);
uint8_t * g_n(uint8_t * x, const uint8_t * y, int w, int nbytes);
int w_n(const uint8_t * x, int nbytes);
</code></pre>
<p>
A concrete, but trivial example of functions f(), g(), and w(),
that exposes just the tip of the iceberg, is:
<ul>
<li>w: Hamming weight</li>
<li>f: rotate right</li>
<li>g: rotate left</li>
</ul>
<p>
I am in the process of patenting my algorithm.
</details>

<h4 tabindex="0" id="2.5.2">2.5.2 Adler32 Redux</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
<address>
Github repo: <a href="https://github.com/avraham-bernstein/adler32-redux">Adler32 Redux</a>
<br>Status: README and complete source code are available
</address>

<p>
This mini-C project is my tweak of the original <a href="https://en.wikipedia.org/wiki/Adler-32">Adler32</a>
hash sum algorithm invented by Mark Adler in 1995.
Even though Alder32 is still commonly (?) used,
it has absolutely ZERO cryptographic strength!
My tweaks overcome all the known flaws with the Alder algorithm while still
retaining its core simplicity and speed. My POC stream cipher variation provides
"good enough security" for many apps, while substituting a stronger cipher would
increase security concomitantly.
</details>

<h4 tabindex="0" id="2.5.3">2.5.3 Dynamic Random Obfuscation of a Single Number which is Homomorphic</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
The following is the basic concept how to randomly obfuscate a number.
This allows the obfuscated arguments to a function call to be different for each call,
while the unobfuscated arguments would be be identical.

<pre><code>
uint32_t obf16( uint16_t x, uint16_t rnd, uint32_t prime17 )  {
    assert( 0x10000 < prime17 && prime17 < 0x20000 );

    return (uint32_t)x + prime17 * (rnd >> 1);
}

uint16_t unobf16( uint32_t obfx, uint32_t prime17 ) {
    assert( 0x10000 < prime17 && prime17 < 0x20000 );

    // note how the random component disappears because it is a multiple of prime17

    return (uint16_t)(obfx % prime17);
}
</code></pre>
<p>
An example of homomorphic obfuscation is the following:

<pre><code>
uint16_t x,y;
uint16_t rnd1, rnd2;
uint32_t prime17;
uint32_t obfx = obf16( x, rnd1 >> 1, prime17 ); // note the necessity of reducing the value of rnd1 & rnd2
uint32_t obfy = obf16( y, rnd2 >> 1, prime17 );
assert( (x + y) == unobf16(obfx + obfy) );
</code></pre>

The following are the full set of C function definitions:
<pre><code>
static uint32_t LocalPrime17;   // 2^16 < p < 2^17
extern uint32_t GlobalPrime17;  // 2^16 < p < 2^17
static uint64_t LocalPrime33;   // 2^32 < p < 2^33
extern uint64_t GlobalPrime33;  // 2^32 < p < 2^33
typedef struct { uint64_t lo, hi; } Obf64_t;

static inline uint32_t ayb_obfLocal16(uint16_t x, uint16_t r)  { return (uint32_t)x + (LocalPrime17 *  (uint32_t)(r >> 1)); }
static inline uint32_t ayb_obfGlobal16(uint16_t x, uint16_t r) { return (uint32_t)x + (GlobalPrime17 * (uint32_t)(r >> 1)); }

static inline uint16_t ayb_unobfLocal16(uint32_t obfx)  { return (uint16_t)(obfx % LocalPrime17); }
static inline uint16_t ayb_unobfGlobal16(uint32_t obfx) { return (uint16_t)(obfx % GlobalPrime17); }

static inline uint64_t ayb_obfLocal32(uint32_t x, uint32_t r)  { return (uint64_t)x + (LocalPrime33 *  (uint64_t)(r >> 1)); }
static inline uint64_t ayb_obfGloba32(uint32_t x, uint32_t r)  { return (uint64_t)x + (GlobalPrime33 * (uint64_t)(r >> 1)); }

static inline uint32_t ayb_unobfLocal32(uint64_t obfx)  { return (uint32_t)(obfx % LocalPrime33); }
static inline uint32_t ayb_unobfGlobal32(uint64_t obfx) { return (uint32_t)(obfx % GlobalPrime33); }

static inline Obf64_t ayb_obfLocal64(uint64_t x, uint32_t r1, uint32_t r2)   {
    Obf64_t obfx;
    obfx.lo = ayb_obfLocal32((uint32_t)x, r1);
    obfx.hi = ayb_obfLocal32((uint32_t)(x >> 32), r2);
    return obfx;
}
static inline Obf64_t ayb_obfGlobal64(uint64_t x, uint32_t r1, uint32_t r2)   {
    Obf64_t obfx;
    obfx.lo = ayb_obfGlobal32((uint32_t)x, r1);
    obfx.hi = ayb_obfGlobal32((uint32_t)(x >> 32), r2);
    return obfx;
}

static inline uint64_t ayb_unobfLocal64(Obf64_t obfx) {
    return (uint64_t)ayb_unobfLocal32(obfx.lo) | ((uint64_t)ayb_unobfLocal32(obfx.hi) << 32)
}
static inline uint64_t ayb_unobfGlobal64(Obf64_t obfx) {
    return (uint64_t)ayb_unobfGlobal32(obfx.lo) | ((uint64_t)ayb_unobfGlobal32(obfx.hi) << 32)
}
</code></pre>
</details>
<h4 tabindex ="0" id="2.5.4">2.5.4 Generation of Latin Squares and Full Cycle Permutations</h4>
<p>
TBD

<h4 tabindex="0" id="2.5.5">2.5.5 2^N Hash Table</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
Typically hash table algorithms face the following challenges:
<ol>
<li>They require a sparse array of slots where each record stored there contains its key and associated data. (In theory the data size can be minimized if we are willing to store the data as pointer).
</li>
<li>The initial attempt to store a record is related to its key.
</li>
<li>If the attempt fails then most implementations use double hashing.
</li>
<li>The slot selection operation using the modulo (i.e. the division) operator.
</li>
<li>When the hash table grows, all records have to be rehashed.
</ol>
<p>

I developed the intial version of my hash table algorithm in 1991, when I needed a symbol table for a compiler that I was writing.
(I was developing a C compiler for a new DSP CPU developed by DSPG. This date was just before the time that it became more practical to develop a compiler for a new architecture using the gcc toolchain). With minor modifications, I used it in real-time environments. I have used it as MAC lookup table in network equipment.
The algorithm is extremely efficient. It avoids all of the above problems. Subsequently I have reused it almost every time that I needed to use a custom hash table algorithm.

<ol>
<li>
The hash table has a data storage area that contains the maximum number of records to be handled by the table.
It is not designed to be sparse.
</li>

<li>
Insertions are extremely fast, i.e. O(1). The new record is always inserted in the first available data slot,
The new record is placed at the head of the list associated with the record's key group.
</li>

<li>
In order to handle efficient insertion and deletion of data record slots, all empty data records contain an index that points to the next free/unused data slot.
</li>

<li>
Data records have two key related indices, one which points to the previous record slot in its key group, and the second points to the next record slot in the group.
</li>

<li>
Effectively all records in the same key group are part of a linked list.
It is the job of the hash function to make sure that the lists are equally and randomly distributed.
</li>

<li>
Searching for a key requires linearly traversing the linked list. But since every data record contains the full 64-bit key, it is rare where there is a full collision that requires that the data also be checked in order to resolve it.
</li>

<li>
The key array is of size 2^N. Normally it should have enough room for at least twice the number of data slots.
</li>

<li>
A key enters the key array at index <code>key & mask</code> where the <code>mask=(1 << N)-1</code>.
</li>

<li>
All keys which match this index are in the same key group.
When there are no data records in a key group, then value associated with the index is zero.
And when there are data records, then the value associated with the index is the first data slot in the key group.
</li>

<li>
The hash table is designed to grow - typically to 16 times its original size. There is a an array that has room for 16 pointers to equal sized data storage areas.
</li>

<li>
When a hash table grows, no records move, and their slot indices remain the same.
</li>

<li>
When it grows, some key groups will split into two, which means that the 2 key-related indices for data records in the group will be updated.
</li>
</ol>
<p>
Source code: TBD
</details>



<h4 tabindex="0" id="2.5.6">2.5.6 CC-BASE.H: Common base C preprocessor definitions for both C and C++, for multiple compilers and multiple O/S
</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
<address>
Github repo: <a href="https://github.com/avraham-bernstein/cc-base.h">cc-base.h</a>
<br>Status: Soon. (Already implemented. Just organizing the code for xfer to Github).
</address>
<p>
This project defines the common base C preprocessor definitions for both C and C++, for multiple compilers and multiple O/S.
<p>
It is designed to unify the C preprocessor definitions in the following environment.
<ul>
<li>different languages: C, C++
</li>
<li>different versions of C: C99, C11
</li>
<li>different versions of C++: C++03, C++11, C++14
</li>
<li>different compilers: gcc, clang, msvc
</li>
<li>different O/S: linux, ios, windows
</li>
</ul>
<p>
The goals are:
<ol>
<li>To minimize the need for inserting "ifdefs" inside project source code.
</li>
<li>To minimize the need for creation of virtual layers/drivers for the O/S, language, or compiler.
</li>
<li>To provide a uniform syntax for generic "typeless" programming, using the macro CC_AUTO(varname,value), where the compiler can infer the variable type from its value, and therefore its type need not be specified. The challenge is that C99, C11, C++03, C++11, and C++14 all have a different syntax for specifying this same logical construct. For example:
<pre><code>
	int x = 42;
	CC_AUTO(y,x);
	// ==> gcc/clang: C99 & C++03:	__typeof(x) y = x
	// ==> gcc/clang: C11:		__auto_type y = x
	// ==> gcc/clang/msvc: C++11:	auto y = x
	// ==> gcc/clang/msvc: C++14:	decltype(auto) y = x
</code></pre>
</li>

<li>To provide a macro "wrapper" for specifying compiler specific attributes and pragmas that the preprocessor ignores when the associated compiler is not present. And similarly to provide the infrastructure for specifying logically equivalent attributes and pragmas via a generic macro that the preprocessor resolves to the compiler specific variant.
</li>
</ol>
<p>
LANGUAGE MINIMUM REQUIREMENTS:
<ul>
<li>C99: full
</li>
<li>C11: optional
</li>
<li>C++03: full
</li>
<li>C++11: optional
</li>
<li>C++14: optional
</li>
<li>C++ Boost library must compile: yes
</li>
</ul>
<p>
COMPILER MINIMUM REQUIREMENTS:
<ul>
<li>gcc v4.6.4+ (Apr 2013)
</li>
<li>clang v3.4.2+ (June 2014)
</li>
<li>Ubuntu 14.04.1 LTS, Trusty Tahr (July 2014)
</li>
<li>MSVC 1900+ (2015)
</li>
</ul>
<p>
O/S SUPPORT:
<ul>
<li>Android
</li>
<li>IOS
</li>
<li>Linux
</li>
<li>Win32
</li>
</ul>
<p>
COMPILERS ACTUALLY TESTED:
<ul>
<li>gcc/g++ v5.4.0 (June 2016)
</li>
<li>clang/clang++ v3.8.0 (March 2016)
</li>
<li>Ubuntu 16.04.2 LTS, Xenial (Feb 2017)
</li>
</ul>
<p>
TEST ENV: Ubuntu 16.04, gcc/clang
</details>

<h4 tabindex="0" id="2.5.7">2.5.7 Mini-Boost.h: Minimal set of boost-like macros for the C preprocessor</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
<address>
Github repo: <a href="https://github.com/avraham-bernstein/mini-boost.h">mini-boost.h</a>
<br>Status: Soon. (Already implemented. Just organizing the code for xfer to Github).
</address>
<ol>
<li>This is grossly scaled down version of Paul Mensonides (i.e. the author of Boost) experimental <a href="https://sourceforge.net/projects/chaos-pp/">Chaos Preprocessor</a> project.
</li>
<li>While "cpp", i.e. the C macro preprocessor, can do much more than how typical programs use it, it is still limiting and brittle.
</li>
<li>Full fledged preprocessing requires a tool like <a href="http://jinja.pocoo.org/docs/2.9/">Jinja2</a>.
</li>
<li>Still I have attempted to create a minimal set of macros which upgrade the C preprocessor into another dimension while not smashing
its envelope.
Regardless, some of the macros that I have defined cannot be nested, and when an attempt is made to unsuccessfully nest them then the resulting
errors are inexplicable.
</li>
<li>max vec len 64
</li>
<li>can do vec bit ops
</li>
<li>can do vec add/sub of a single bit to a 6 bit number
</li>
<li>CC_SIZE, CC_IF, CC_DEFER
</li>
<li>CC_HEAD, CC_SELECT, CC_MAP, CC_MAP2, CC_JOIN, CC_REV, CC_IOTA, CC_REP
</li>
<li>major goal: can implement stream cipher on up to 64 char vec
</li>
</ol>
</details>

<h4 tabindex="0" id="2.5.8">2.5.8 OOC: Light weight object oriented C framework</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
<address>
Github repo: <a href="https://github.com/avraham-bernstein/ooc">ooc</a>
<br>Status: Soon. (Already implemented. Just organizing the code for xfer to Github).
</address>
<p>
OOC efficiently handles composite classes and interfaces (similar to Go).
<p>
And OOC solves the C namespace problem. All class methods, except for "new", are implemented as function pointers,
where the actual function is implemented as a "static". Therefore each class can have their own private
open(), close(), read(), write() functions etc. without conflicting with other classes.
<pre><code>
MyClass_t * p;
p->open(p,...);
p->close(p, ...);
p->read(p, ...);
p->write(p, ...);
</code><pre>
</details>

<h4 tabindex="0" id="2.5.9">2.5.9 Obfuscated Forth Compiler</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
<address>
Github repo: <a href="https://github.com/avraham-bernstein/obf-forth">Obf-Forth</a>
<br>Status: TBD. (Once upon a time I built such a tool, but I lost the source code).
</address>
<p>
The <a href="https://en.wikipedia.org/wiki/Forth_(programming_language)">FORTH</a> programming language produces very dense and very efficient interpreted code. In order to accomplish these feats, it uses RPN (reverse Polish notation) syntax which greatly simplifies the interpreter. The first version of FORTH was developed in 1968 by Chuck Moore. It becames standardized with FORTH83 and FORTH94.
<p>
FORTH is an extremely efficient way to download dynamic scripts into an application
that already has a built-in embedded FORTH interpreter - similar to embedded <a href="https://www.lua.org/">Lua</a>.
If we are willing to disallow dynamic editing of FORTH scripts then we can produce
an extremely compact FORTH interpreter with a size of only a few K bytes.
<p>
MP4 is a commonly used format in the video industry.
Recently the MP4 protocol allows non-video user specified payloads to be included in the stream.
Therefore we could dynamically push FORTH scripts into the video player application which could be used for security purposes.
Obviously we require that these scripts be obfuscated.
<p>
My proposed solution not only obfuscates the script, but obfuscates the FORTH interpreter.
In theory we would like to see that every player app has its own version of the interpreter,
say based upon the low 4 or 8 bits of its MAC address or subscriber UUID.
Modern CDNs, <a href="https://en.wikipedia.org/wiki/Content_delivery_network">content delivery networks</a>,
have the tools to download differentiated content.
<p>
There are other projects that could benefit from obfuscated Forth.
<p>
Most assembly code reverse engineering hackers dislike having to deal with custom VMs (i.e. virtual machines)
because they don't have the tools to automatically handle them.
<p>
Even though many programmers are not familiar with FORTH, there are a already a number of existing prototypes that compile C to FORTH.
It would be a straightforward compiler project that would target FORTH instead of assembly.
Also I already once did a gcc port to a stack based CPU architecture with a FORTH-like instruction set.
<p>
Besides implementing obfuscated FORTH in C, today it may be worthwhile to implement it also using Web Assembler (WASM).
Also it would be an excellent first project to "cut my teeth" on WASM.
</details>

<h4 tabindex="0" id="2.5.10">2.5.10 Jinja2 CLI Wrapper</h4>
<p>
<details>
<summary><span class="readmore"/></summary>
<address>
Github repo: <a href="https://github.com/avraham-bernstein/j2-cli">j2-cli</a>
<br>Status: Soon. (Already implemented. Just organizing the code for xfer to Github).
</address>
<p>
<a href="http://jinja.pocoo.org/docs/2.9/">Jinja2</a> is the ultimate macro preprocessor and template engine that can be applied to any set of text files,
whether HTML, C/C++, Linux configuration files, or a Pandoc Markdown documentation project.
</details>

</details>

<h3 tabindex="0" id="2.6">2.6 Computer Languages &amp; Programming Philosophy Musings</h3>
<details>
<summary><span class="readmore"/></summary>
My "goto" languages are C, bash shell &amp; Posix utilities, Python, TCL, Jinja2, and Pandoc Markdown.
Less regularly I use C++, Javascript, HTML5 &amp; CSS3, Java, Go, and Forth. (I think that I should upgrade Go to my "goto" category).
Infrequently I use C#, Prolog, Lisp, Fortran, and Pascal.
I have experience writing compilers, and I regularly write domain specific languages for most problems that I tackle.
Therefore usually I can pick up a new language within a day or two, and become an expert within 2 weeks.
I have a deep understanding of how operating systems work. My strong preference is the Linux-like and Posix flavors of operating systems,
but once-upon-a-time I was an expert in Win32. In 1983 one of my first jobs was writing a real-time operating system kernel for an
<a href="https://en.wikipedia.org/wiki/Intel_8080">Intel 8080</a> CPU based data collection terminal,
followed by working on the embedded software for the radar on the <a href="https://en.wikipedia.org/wiki/IAI_Lavi">Lavi fighter plane</a>.
I wrote my first real program in high school in 1971 in order to play a perfect game of 3D (4x4x4)
<a href="https://en.wikipedia.org/wiki/Tic-tac-toe">Tic-Tac-Toe</a> in FORTRAN using
<a href="https://en.wikipedia.org/wiki/Mark_sense">mark sense cards</a> on an <a href="https://en.wikipedia.org/wiki/IBM_1130">IBM 1130</a>
computer (the size of a refrigerator) with just 16K RAM!
It should be clear from this document that I am an excellent programmer with experience using a wide variety of tools,
but my programming skills should not be your primary basis for deciding to work with me.
At my level, the much more important skills are problem solving &amp; logic, creative vision, business development,
economic, mentoring/teaching/leadership, and communication.
<p>
I would like to learn a new language called <a href="https://nim-lang.org/">Nim</a> with extremely powerful meta-programming features. In some ways it is a new programming paradigm. And I would like to learn another new language <a href="http://webassembly.org/">Web Assembly (WASM)</a> which will revolutionize the way generic HTML5 apps can be efficiently and securely deployed to end users as opposed to the currently more common system of "native" apps. And WASM is being targeted for IoT device apps - which will eventually supply a hardware WASM interpreter - just like once-upon-a-time tiny embedded H/W devices would often supply a Java interpreter. WASM is extremely efficient. It has been embraced/endorsed by all of the major browser vendors. The WASM assembly code is designed to be
generated automatically via the <a href="https://github.com/kripken/emscripten/wiki/WebAssembly">Emscripten C/C++ "transpiler"</a> - and not to be produced manually. Therefore we could apply state-of-the-art C/C++ obfuscation techniques in order to protect keys, and in general to protect the intellectual property of the app developer. Since WASM runs at least an order of magnitude faster than Javascript, the extra overhead associated with the obfuscation will usually not be significant. Here is a document on the <a href="https://github.com/WebAssembly/design/blob/master/Rationale.md">design rationale of WASM</a>.
<p>
Note about C++:
It is not politically correct to say this, but C++ is too dangerous to use for the average project.
<i>Even though during the the architecture phase of a project,
it is critically important to identify common classes and objects, interfaces, and frameworks,
I find that C++ object oriented implementations are highly error prone, and are sinkholes for R&D manpower resources.</i>
Inexperienced architects and programmers create class hierarchies that are extremely brittle with
<a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)">tightly coupled</a> class dependencies.
In performance sensitive and embedded real-time projects most programmers do not understand the C++ language internals
sufficiently in order to realize which language features cannot be used in such an environment.
Therefore I prefer to write C code with an object oriented "flavor".
In my professional opinion, it is much safer to develop using the simpler,
but tried and true, <a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)">encapsulation</a>,
<a href="https://en.wikipedia.org/wiki/Object_composition">composition</a>,
and <a href="https://en.wikipedia.org/wiki/Protocol_(object-oriented_programming)">interface</a> programming techniques.
By the way, this is the philosophy behind the relatively new Go language
- which I feel is ideally suited to become the new important system programming language,
and web backend server language.
And I am in good company, with
<a href="https://developers.slashdot.org/story/15/03/10/2038228/was-linus-torvalds-right-about-c-being-so-wrong">Linus Torvalds</a>
and <a href="https://golang.org/doc/faq">Rob Pike and Ken Thompson</a>.
Remember, Google has embraced Go precisely for the above reasons.
<p>
I am pragmatic. In spite of my reservations about the use of C++ there are certain application domains
where it is the best tool for the job, e.g. compiler construction
where <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">ASTs</a> are easily represented by a deep class hierarchy.
<p>
The most useful syntax feature in C++ that is missing from <a href="https://en.wikipedia.org/wiki/C11_(C_standard_revision)">C11</a> is namespaces.
Therefore in C, it is very important to adhere to a rigorous naming convention. I suggest the following:
<ol>
<li><b>Global Scope:</b> &lt;UpperCamelCaseModuleName&gt;_[&lt;UpperCamelCaseSubmoduleName&gt;_ ...]&lt;LexicalType&gt;_&lt;lowerCamelCase&gt;[_&lt;suffix&gt;]
</li>
<li><b>File Scope:</b> &lt;LexicalType&gt;_&lt;lowerCamelCase&gt;
</li>
<li><b>Function|Struct|Union Scope:</b> &lt;lowerCamelCase&gt;[_&lt;suffix&gt;]
</li>
<li>Lexical Types:
<ul>
<li><b>C</b> = class
<li><b>F</b> = function
<li><b>S</b> = structure
<li><b>T</b> = typedef
<li><b>U</b> = union
<li><b>V</b> = variable
</li>
</ul>
<li>Suffixes:
<ul>
<li><b>arg</b> = function argument
<li><b>arr</b> = array
<li><b>ctx</b> = context
<li><b>fnc</b> = function pointer
<li><b>obj</b> = object
<li><b>ptr</b> = pointer
<li><b>t</b> = typedef | struct | union [function scope]
<li><b>str</b> = zero terminated string
</ul>
<li>Examples:
<ul>
<li><b>global typedef:</b> <br>typedef struct CryptoLite_Prng_Xorshift1024StarPlus_<b>S</b>_ctx { int p; uint64_t s[16]; } CryptoLite_Prng_Xorshift1024StarPlus_<b>T</b>_ctx;
<li><b>global function:</b> <br>extern uint64_t CryptoLite_Prng_Xorshift1024StarPlus_<b>F</b>_next(CryptoLite_Prng_Xorshift1024StarPlus_<b>T</b>_ctx * ctx_ptr);
<li><b>static|file-scope function:</b> <br>static uint64_t <b>F</b>_rotl64(uint64_t x, int k);
</li>
</ul>
</li>
</ol>

<p>
Note about TCL: TCL's popularity is fading.
At the high end, it has been replaced by Python, and at the low end by Lua.
The free open source version of TCL does not have a debugger. The commercial version has a debugger, but at $300/seat.
Junior programmers need a debugger. Advanced users can easily "roll their own".
There are certain industries that still heavily rely upon TCL, e.g. VLSI and Cisco network equipment.
Therefore in a commercial programming environment where my code will be shared and maintained with others,
I have to think twice before using it. Still there are some types of applications where IMHO TCL excels:
<ol>
<li>Designing a <a href="https://en.wikipedia.org/wiki/Domain-specific_language (DSL)">domain specific language</a>
CLI for an application - which enables batch mode, and automated testing.
</li>

<li>
Designing a DSL CLI interface for operating and testing a new piece of hardware or a workstation or a robot.
</li>

<li>
Designing a DSL for a formal architecture specification along with its close relative - a language for a formal testing specification.
</li>

<li>
Note it may very well be the case that the final implementation of the DSL CLI will be in another language, say Lua embedded in C.
But at the specification stage, using TCL is 100 times more simple as long as you understand that the DSL must have the same syntactic "flavor" as TCL itself,
and that if you need a binary extension, generally all one needs to do is to supply a few extra verbs to TCL.
</li>
<li>
For desktop environments the TCL GUI toolkit Tk, is brilliantly designed on account
of its built-in core "pack" command which is a "responsive" geometry manager. Nice widgets can be defined with a few lines of code:
<pre><code>
button .b -text PressMe -bg red -command { puts "hello world" }; # definition of button ".b"
pack .b; # places the button on the display
</code></pre>
No GUI toolkit is simpler. However the alternative native GUI libraries which demand hard coded geometry invariably execute considerably faster, but they are considerably more difficult to code. Python supports Tk (i.e. Tkinter), and so does the "go-tk" project. It is not difficult for a C/C++ app to embed Tcl/Tk. On the other hand, arguably it would be preferable for desktop apps to standardize on Webkit/Blink, so they can build their GUIs with the ubiquituous HTML5 and javascript/WASM infrastructure - which is the most portable solution.
</li>
</ol>
Almost every software project under the sun could be greatly assisted by having an object oriented macro preprocessor and template engine.
I am a big fan of meta programming and automated code generation - which is one
of the common techniques used for implementation of
<a href="https://en.wikipedia.org/wiki/Domain-specific_language">domain specific languages (DSL)</a>.
Forget about the C preprocessor which is extremely primitive and brittle, or the C++ template mechanism which in many cases is esoteric (just take a look at the Boost libraries), and anyway is specific to C++ projects. In my opinion the ultimate tool is <a href="http://jinja.pocoo.org/docs">Jinja2</a>. Jinja2 can be used to preprocess any text file, from C files, to HTML &amp; CSS files, to configuration scripts. Jinja2 is the most popular tool for adding templates to enterprise web sites. (I use it for preprocessing all of my <a href="http://pandoc.org/">pandoc</a> documentation). Google came to the same conclusion for their huge and strategic <a href="https://www.chromium.org/developers/jinja">Chromium</a> projects written in both C and C++. Jinja2 is Python based. In order to make it into a standalone tool, requires the creation of an extremely thin wrapper. Out of the box, Jinja2 comes with a handy set of primitive template operators that service the average project. But it is very easy to extend the language by importing Python packages. One of the most important built-in extensions that my wrapper includes is the "import" operator. Therefore in order to minimize the customizations necessary to produce the wrapper, one can dynamically load Python packages from inside the main template (with no performance hit versus hard-coding it in the wrapper) in order to extend the set of template operators. Therefore if we needed to access the Python built-in packages for regular expressions or for base64 encoding, we can create two template variables <code>{% set re = import("re") %}</code> or <code>{% set b64 = import("base64") %}</code>, and use them to access the standard Python interface from inside a template. For example <code>{% set encoded_string = b64.b64encode("abcd") %}</code>. BTW I found big flaws in the design of the competing <a href="https://golang.org/pkg/text/template/">Go text template engine</a>, which I have also tested extensively. Namely it has <a href="http://blog.ojrac.com/go-html-templates-not-jinja2.html">less built-in features than Jinja2</a>, it is more difficult to extend, and it is not possible to create first class macros that return values (without programmatically extending the engine).

<p>
One of the worst "sins" that a programmer can make is repeating himself. Copying and pasting the same block of code, or the same block with standard variations, to many different locations in the source code is very dangerous because when updating the code, it is more often than not the case that you'll forget to update every single location where the code was originally pasted. The solution is to use macros for trivial instances, and templates for more complex ones. The problem is that many programmers are constitutionally incapable of programming in 2 different languages simultaneously, i.e. the core programming language and the macro/template language. (BTW in the case of C/C++ it is possible to wrap the templates in C preprocessor macros that make them look like native code). Another reservation is due to the fact that the Makefile has to be modified to call a preprocessing step prior to the compilation step. They have no choice other than to get over it.
<p>
Another related issue is to take generic programming more seriously. I am not only referring to the well known techniques of templates, function overloading, or C11 <code>_Generic</code>. There are 2 grossly underutilized keywords in C11/C++11, i.e. <code>__auto_type</code> and <code>auto</code> respectively. These keywords allow <i>typeless</i> programming! For example <code>auto x = y;</code> is a valid assignment statement where the compiler already knows the type of 'y'.

<h4 tabindex="0" id="software-quality">2.6.1 Musings about building quality and secure software</h4>
<p>
<ol>

<li>I am a firm believer in the use of the <a href="https://en.wikipedia.org/wiki/Design_by_contract">Design By Contract (DBC)</a> programming methodology which is implemented by liberal use of "assert" statements in order to detect <i>dynamic</i> programming errors.
In my experience most programming errors, which are often very difficult to detect, are due to the following:
<ol>
<li>incorrect understanding of the restrictions/assumptions placed on the parameters to a function call, e.g. what are the minimum and maximum values that a parameter can take?
</li>
<li>incorrect understanding of the edge cases, e.g. should the loop be from 0..n, 1..n, or 0..(n-1)?
</li>
<li>not doing a simple sanity test of a variable before allowing a function to return its value, e.g. a function that can never return a negative number
</li>
<li>and similarly not checking the return status of a function before using its results
</li>
</ol>
Once the kinks are out a system, most of these dynamic tests can safely be turned off - unless a parameter results from user input in which case a validation routine is required instead of an assertion. During the development stage these assertions are invaluable. DBC is language agnostic. Inexplicably to me at least, DBC is not that popular?

<li>GCC, and especially clang, support many function attributes for detecting <i>static</i> errors, e.g. <code>nonnull</code>. And of course there are many "lint" tools, both open source and commercial. <a href="http://www.gimpel.com/html/index.htm">Gimpel</a> is a little expensive, but it is the "gold standard". Where the cost of the tool is a very important issue note that the Linux and Mac versions cost about $1K per seat while the PC Windows version is "only" $389. In many cases it is possible to use a network drive to pass the lint tests to a physical Windows machine or a virtual one.
</li>

<li>
And it goes without saying that by default, all C/C++ projects must be compiled with "-Wall" before checking in source code to the version control system.
Trivial warnings that are expected <i>a priori</i> can usually be simply overridden by assigning the appropriate attributes to specific variables and functions, e.g. <code>unused</code>. In more complex cases, <code>#pragma GCC diagnostic ignored ...</code> can be added to specific sections of the source code in order to ignore specific warnings, surrounded by <code>#pragma GCC diagnostic push</code> and <code>#pragma diagnostic pop</code> in order to localize the override.
Many projects ignore this rule with the consequences that most compilations generate hundreds or thousands of warnings.
There are so many that it is impossible to take any of them seriously.
</li>

<li>A module should always supply a unit test function.
</li>

<li>Every module needs to have an informal "peer" code review - long before a formal code review by project technical management.
My professional experience along with the professional literature have unequivocally shown that about 50% of the bugs are flushed out
by the programmer himself during the simple process of him being forced to explain to a colleague,
the rationale behind every single line of his code.
It is the single most cost effective debugging technique.
</li>

<li>Every large and medium sized project should have a domain specific language (DSL) for enabling batch execution.
</li>

<li>The GUI should not directly call an app's binary API. Instead it should generate DSL script. (And for security reasons, lightly encrypted if necessary). It makes recording and testing 1000 times easier than using tools that record low level UI operations with no semantic meaning, such as physical mouse movements, and button presses, and individual keystrokes.
</li>

<li>In test mode, the DSL should provide access to each module's unit test function.
</li>

<li>
Using a DSL makes it trivial to apply <a href="https://en.wikipedia.org/wiki/Fuzzing">fuzzing</a> tools
</li>

<li>
Before a developer makes a final check-in of the source to the version control system, he must run an automated DSL script sanity test. And in the middle of every night, the
CI (continuous integration) system should execute a full set of automated regression tests built using a DSL script.
</li>

<li>
Every app should supply 2 logging tools, a full fledged one for the developers, and a much simpler one for the end users that simply logs the DSL script so customer support can easily repeat what the end user did. The developer version should have a dynamic filter mechanism that turns debugging on and off for specific modules, otherwise the developers could become inundated with log messages that may have a significant negative impact on performance.
</li>
<li>
Most projects should have a text configuration file mechanism. (Note how many configuration settings there are in Mozilla Firefox - open the virtual URL "about:config"). Where security issues are involved then 2 files may be necessary, where the security configuration file is cryptographically signed and/or encrypted. A key ladder mechanism may be required, where trusted intermediate parties need to add their own keys. Where the end user does not have to directly make changes in the configuration file, it is possible to parse the configuration file off-line, and to supply the configuration file as a binary blob that matches the low level .h interface of the configuration file structure. This binary blob technique is faster, and more secure, and precludes the need to supply an on-line parser. The minor challenge in this implementation is to make sure there is a variable sized configuration heap at the end of the structure in order to store strings, etc. Python provides packages that I used to implement this binary blob configuration concept - namely "struct" in conjunction with "configParser".
</li>
<li>
Security keys should normally be supplied as cryptographically "wrapped", and where possible be unwrapped just-in-time. Avoid unwrapped, i.e. in-the-clear, keys because it is often possible for an attacker to gain access to the binary code, where the keys stand out like a sore thumb. Unfortunately in most cases the master key <i>must</i> be embedded/injected into the binary. There are many techniques to protect it. A simple one is to break it into the pair, <code>master^rnd</code> &amp; <code>rnd</code>, where <code>rnd</code> is automatically regenerated every build. WhiteCryption's commercial SKB package provides a much more elegant solution, combined with the feature that their crypto library works with wrapped keys so there is no reason ever to unwrap them.
</li>
<li>
Never forget that bugs are very expensive to fix. There are development costs, customer support costs, customer dissatisfaction, and sometimes the very expensive customer delivery costs of deploying the updated app in the field. (Although it is becoming more prevalent for many platforms to provide a mechanism for automatically pushing updated apps to the end users, but not in secure environments either military or civilian).
</li>
</ol>

</details>

<h3 tabindex="0" id="2.7">2.7 Spoken Languages</h3>
<details>
<summary><span class="readmore"/></summary>
English (5/5), Hebrew (4/5), French (2/5).
</details>

</details>

<h3 tabindex="0" id="2.8">2.8 Conclusion: C-level Executive Skills</h3>
<p>
Besides being a state-of-the-art computer scientist and technologist, I am also an economist.
I am an excellent mentor. I have had a number of proteges who I have helped to become experts. (My first was Rina Feldheim).
I write and speak very well. English is my mother tongue. I am an
<a href="http://autodidactpolymath.com/autodidact-polymath-definition/">autodidact polymath</a>&nbsp;<sup><a href="#polymath-footnote">4</a></sup>.
I am an <a href="http://99u.com/articles/7269/picasso-kepler-and-the-benefits-of-being-an-expert-generalist">expert generalist</a> with eclectic (= wide ranging) interests, and make it my personal business to become very well updated on a broad range of technologies. I understand the
<a href="https://www.joelonsoftware.com/2002/06/12/strategy-letter-v/">economic</a> environment of the projects and industries in which I work.
And I am able to effectively distill and to convey this information/vision to the relevant parties, whether they be investors, customers, senior management, or employees.
Here is an outstanding TED talk (20 min.) about
<a href="https://www.youtube.com/watch?v=Mtjatz9r-Vc">what characterizes great, innovative, and economically successful technology, and how to effectively present it</a>.
And here is a very short article that <a href="http://www.techrepublic.com/article/4-tips-to-help-tech-leaders-make-it-to-the-c-suite/">
summarizes the requirements of a C-level executive</a>.

<h2 tabindex="0" id="3.0">3.0 About: Personal</h2>
<p>
<details>
<summary>
I was born in Canada in 1956. I have lived in Jerusalem Israel since 1983.
I am an observant God-fearing<sup><a href="#fear-of-god-footnote">6</a></sup> Jew. I am married to my wife Judy since 1978.
God blessed us with 4 beautiful children (2B+2G), plus many grandchildren - who all live in Israel.
I take physical fitness seriously.
Once upon a time I was a judoka, a classical guitarist, and composer<sup><a href="#music-composition-footnote">7</a></sup>.
I was an IDF reserve soldier for 14 years, where I served as a combat soldier in the infantry in the Jordan Valley.
In spite of the fact that I joined the army when I was 32 years old (Hebrew: <i>Shlav Betnik</i>),
functionally, but unofficially, I served in the capacity of deputy company commander (Hebrew: <i>Samech Mem Pe</i>)
which provided me with the opportunity to achieve rich personal growth,
and enabled me to learn important managerial and leadership skills.
<br><span class="readmore"/>
</summary>
<p>
To this day I have been involved in a number of battles against "the system" in order to correct major injustices. The following are a few examples:

<ol>

<li>In 1977, at the Ontario Energy Board (OEB) electricity costing and pricing hearings,
while a student in the Univ. of Toronto MBA program, I contested an extremely well funded
industry coalition that argued against implementation of "marginal cost pricing"
(aka "peak-load" or "time-of-day" pricing) simply because their industries smelted metal
with electric blast furnaces so changing from "flat pricing" would be ruinous to their industry,
even though it was clear that flat pricing was outrageously unfair to the average consumer,
and posed a huge burden to the macro economy due to the intended massive financial outlays
to unnecessarily expand generation capacity with nuclear power plants.
But due to extreme political pressure from the metal processing industry, the government of
Ontario forced the utility (i.e. Ontario Hydro) to withdraw their proposal.
The disgruntled economists from the utility helped me from behind-the-scenes to be the sole
intervenor (= legal participant) at the hearings to present their marginal cost pricing proposal.
I did not win the case, but I was the first intervenor in the history of the OEB to be awarded costs.
I also published a detailed op-ed in "The Globe and Mail", Canada's paper of record, describing the issues at the hearings.
<p>
</li>

<li>In 1996, at the Israel Supreme Court, I successfully challenged the IDF's <i>illegal and politically motivated</i>
rules of engagement orders when a general publicly gave me an order that if a Palestinian "policeman" were to aim his
rifle at me or another soldier or a civilian then no soldier was permitted to respond until <i>after</i> the bullet
left the terrorist's rifle!
<p>
</li>

<li>More recently since 2015, against Jerusalem social services, it seems that after a 2 year legal battle
there is a 95% chance, please God, of liberating 3 young children who they permanently "snatched"
(i.e. institutionalized, and subsequently sent to foster care) from their parents claiming that
the father had sexually molested one of his daughters, when in fact the girl was molested twice
inside social services own institutions by another young child whose father had molested him.
Even the children's court appointed legal guardian (Hebrew: <i>Apitropus</i>) was also a party to the perjury and obstruction of justice.
I provided the court with incontrovertible evidence of these facts.
For example I instructed the father to secretly record his conversations with social services,
while I did the same during my conversations with them.
(Note that in Israel, as well as many other jurisdictions, secretly recording a conversation by a party to the conversation is legal).
Note that social services is effectively an arm of the police, and family court judges always give them the benefit of the doubt,
and are loathe to recommend to the police that they be charged with perjury, obstruction,
breach of trust, malfeasance, criminal and professional negligence, etc.
Therefore the judge has provided us with a way to liberate the children by agreeing
to the recommendations of a private psychologist who we recently hired (April 2017),
in spite of the wild opposition from social services.
This way the judge avoids a circus in his courtroom where we would be allowed the right to document discovery,
and to subpoena and examine as hostile witnesses the officials from social services.
<ul>
<li>Update 2017-10-11: The psychologist recommended that the father be awarded custody of all his children, thank God!
The final hearing in order to approve the report will be held in November 2017.</li>
<li>The reason that I became so heavily involved in this particular case,
besides the inherent outrageous injustice of maliciously and falsely accusing a father of sexually molesting his own child,
is because the father's grandparents were also my wife's uncle and aunt.
When my wife was a teen, they gracioulsy allowed my wife to live at their home for two years.
Therefore I feel that I am repaying this nearly 50 year old debt of gratitude now that their
grandchildren and great-grandchildren are in desperate need of help.</li>
<li>And during the course of the legal battle, early on my wife and I offered to be the
<a href="https://en.wikipedia.org/wiki/Kinship_care">kinship foster parents</a> in order
to liberate the children from the dungeon run by social services. After we received
initial approval from the fostering agency, social services convened a special committee to overturn this
approval because we had allowed the father to be unsupervised around our own young grandchildren.
Since we were aware of their accusation that he was a pedophile,
therefore this proved that we were negligent grandparents,
and <i>a fortiori</i> would be negligent foster parents!
Therefore the children remained institutionalized for another year at a great emotional cost to them
and their father, and at a huge financial cost to the State.
When after a year the fostering agency finally found an alternative set of foster parents,
the foster mother openly admitted that she had discovered the initial sexual abuse committed by another
child that took place inside a social services institution where she had been directly responsible for
the care of these children.
Yet the fostering agency still refused to allow the father unsupervised visits with his children,
because they had been warned by social services that he was a pedophile!
We were dealing with an evil Kafkaesque bureaucracy.</li>
</ul>
</li>
</ol>

Against formidable odds, I was successful.
Others feared to engage in those battles due to their sense of hopelessness in the face of the overwhelming power of the system,
or due to social pressure for fear of being labeled "politically incorrect".
From these battles, I have learned the "power of one", i.e. of a single individual, to make the world a better place,
in spite of these formidable odds.
Some of my fighting technique I learned from martial arts, namely how to fight against a stronger opponent,
yet still manage to throw him off balance, very similar to the principles of <a href="https://en.wikipedia.org/wiki/Asymmetric_warfare">asymmetric warfare</a>.
I would like to believe that I have internalized the aphorism of the great Jewish sage <a href="https://en.wikiquote.org/wiki/Hillel_the_Elder">Hillel</a> (<i>circa</i> 50 <a href="https://en.wikipedia.org/wiki/Common_Era">BCE</a>) recorded in <a href="https://en.wikiquote.org/wiki/Pirkei_Avot">Pirkei Avot</a>, "in a place where there are no men, strive to be a man".
<p>
Recently I have received a number of negative comments about the inclusion of this section from my close friends,
who are more often than not my professional colleagues - which is frequently the case in Israel.
Allow me to explain why this information is critically important to round out my "professional" experience.
Just like my non-controversial (at least in Israel) military experience shows management and leadership skills,
these other experiences show the following:
<ul>
<li>resourcefulness, strategical, and tactical skills in the face of an opponent/competitor
who has much greater resources at his disposal</li>
<li>resiliancy to bounce back and continue to fight in spite of temporary setbacks</li>
<li>not being afraid to trust my own intuition in situtations where others fear to tread</li>
<li>tenaciousness to achieve my objectives</li>
</ul>
<p>
These skills may not be relevant to software engineering, but they most certainly
are critical to anyone who has a key management position in any business - especially a start-up.
</details>

<h2 tabindex="0" id="footnotes">Footnotes</h2>
<p>

<ol>

<li id="secure-photo-footnote">
This secure photo was built using blurring filters along with a visible email address <a href="https://en.wikipedia.org/wiki/Digital_watermarking">watermark</a>. It uses <a href="https://io9.gizmodo.com/5510040/designer-reverse-engineers-face-detection-tech-to-develop-camouflage-makeup">digital camouflage</a> that will defeat almost all face matching algorithms - in spite of the fact that my 3 year old grandson has no problem identifying me from this photo. It protects my privacy in two ways. (1) Harvesting it from the Internet, and adding it to a database of photos that will be compared with CCTV surveillance photos will not work. (2) The photo has built-in <a href="https://en.wikipedia.org/wiki/Multi-factor_authentication">two factor authentication (2FA)</a>. The prominent email address watermark prevents a web site from maliciously displaying my photo while attempting to associate/label it with any other name besides mine. Similarly if a site were to maliciously display my photo without my permission in order to imply my association or agreement with them, then it is trivial for anyone who may be suspicious of their claim to "challenge" the site by asking me for a verification email.
</li>

<li id="anti-harvesting-footnote">
<a href="https://en.wikipedia.org/wiki/Email_address_harvesting">Anti-harvesting</a> privacy protection via CSS without the use of Javascript. See HTML source.
</li>

<li id="scp-footnote">
<a href="https://www2.cs.arizona.edu/~collberg/">Christian Collberg</a>, one of the most well known academics in the field of obfuscation,
told me in 2016 that he felt that SCP was the best designed commercial obfuscating compiler in the market.
</li>

<li id="polymath-footnote">
There is a common misconception that only people like Leonardo da Vinci deserve the appellation "autodidact polymath",
and therefore by referring to myself as such I am making the bombastic claim to be a genius in the same category as Leonardo.
There is an outstanding <a href="https://www.ted.com/talks/sugata_mitra_shows_how_kids_teach_themselves">TED talk</a>
showing how children from Indian slums with the apppropriate nuturing can become autodidact polymaths.
And there is an educator from <a href="https://www.wired.com/2013/10/free-thinkers/">Mexico</a> showing
similar results with children from Mexican slums.
Many very intelligent people, especially as they get older, don't like moving outside of their intellectual comfort zone,
whereas I revel in taking on intellectual challenges in new fields outside of my comfort zone.
Note my "grand slams" in a wide range of application domains - where the only way to quickly achieve expertise
was self-learning admittedly with the help of highly qualified mentors - who I have a knack for finding, and who recognize my potential.
I feel that I still maintain a high degree of child-like mental plasticity.
Part of this skill I retain by regular interaction with my own young grandchildren,
where my play with them is much more analytical than I used to exhibit with my own children.
</li>

<li id="mrsa-footnote">
<a href="https://en.wikipedia.org/wiki/Methicillin-resistant_Staphylococcus_aureus">MRSA</a>
is a deadly strain of antibiotic resistant staphylococcus bacteria that thrives in hospitals,
and is the number one cause of fatal infections in hospitals (aka <a href="https://en.wikipedia.org/wiki/Iatrogenesis">iatrogenesis</a>).
<ul>
<li>Lack of proper hand hygiene is one of the major vectors for spreading MRSA.
The clothes, hair, skin, and personal instruments of hospital staff could become covered with MRSA.
About 7% of the general population naturally carry MRSA inside their noses with no adverse effects
as long as they do not become immunologically compromised (e.g. become seriously ill).
However if a carrier touches the inside of his nose,
and then directly or indirectly touches (e.g. via a common surface such as a hand or door handle)
an open wound, especially of one who is immunologically compromised, then the results could be fatal.
The most effective topical <i>preventative</i> treatment against MRSA is the natural remedy "thieves oil"
developed by herbalists over a thousand years ago in order to prevent grave robbers from getting infected
by the graves of the infected corpses that they pillaged.
Thieves oil is a mixture of essential oils such as cinnamon, lavender, lemon grass, etc.
Serious/recognized medical studies are beginning to recognize the effectiveness of
essential oils as anti-bacterials.
For example see articles from <a href="https://www.ncbi.nlm.nih.gov/pubmed/15555788">NIH</a>,
<a href="http://www.nytimes.com/2009/09/08/health/08real.html">France</a>,
and <a href="https://www.theatlantic.com/health/archive/2015/01/the-new-antibiotics-might-be-essential-oils/384247/">livestock and poultry farming</a>.
</li>

<li>A related very serious staphylococcus infection is <a href="http://www.mayoclinic.org/diseases-conditions/cellulitis/basics/definition/con-20023471">cellulitis</a>
where the vector for the infection are skin lesions and abrasions
resulting from accidents or insect bites or from chronic skin problems resulting from dry and cracked skin or raw skin,
e.g. even an infant learning to crawl whose knees develop abrasions.
The above NIH study found benefits dressing these wounds with essential oils.
</li>

<li>There are new inventions of <a href="https://www.israel21c.org/the-startup-aiming-to-conquer-hospital-acquired-infections-2/">anti-microbial fabrics</a>
and <a href="https://www.meddeviceonline.com/doc/shark-skin-inspires-antimicrobial-surfaces-0001">shark skin anti-microbial surfaces</a>
which prevent the spread of MRSA in hospitals.
</li>

<li>There are some recent promising studies that indicate that there are natural non-antibiotic remedies for <i>curing</i>
MRSA even after it has entered the blood stream, i.e. <a href="http://www.sepsis.org/sepsis-and/cellulitis/">sepsis</a>,
which is often fatal even in those who are not immunologically compromised.
See <a href="http://articles.mercola.com/sites/articles/archive/2017/04/05/vitamin-c-b1-hydrocortisone-reduce-sepsis-mortality.aspx?utm_source=dnl&utm_medium=email&utm_content=art1&utm_campaign=20170405Z2&et_cid=DM141720&et_rid=1956015364">
vitamin C, B1 and hydrocortisone</a> and the <a href="https://www.sciencedaily.com/releases/2017/02/170210084534.htm">brazillian peppertree</a>.
</li>

<li>Well funded <a href="https://biomimicry.org/what-is-biomimicry/">biomimicry</a> investigations should be made of
<a href="https://www.theguardian.com/society/2016/sep/24/ants-solution-to-antibiotic-crisis-superbug-bacteria">fungus farming ants</a>.
These ants naturally produce their own antibiotics in order to keep their fungus healthy.
After 75 years of widespread human use of antibiotics,
the result has been the catastrophic growth of new mutant strains of "super bugs" that are resistant to antibiotics.
Clearly these ants know something that we don't.
</li>

<li>I wonder why the 7% of the population who are carriers of MRSA in their noses are not adversely effected,
and especially what is the mechanism that prevents the MRSA from crossing into their sinus tracts and blood systems
when they have sinus infections and nose bleeds respectively?
</li>
</ul>
</li>

<li id="fear-of-god-footnote">The most fundamental tenet of Judaism is that God watches over every single person in the world 24x7,
and that God holds Man responsible and accountable for his actions.
A person's beliefs are secondary.
Every man, whether Jewish or not, has an annual day of judgement on <i>Rosh Hashana</i>,
and every man has a final judgement on the day he meets his Maker.
Therefore every intelligent person ought to have a "fear of God".
<ul>
<li>Most modern scientists recognize that there was a Creator of the universe.
However, just like Aristotle in his day, they doubt whether the Creator is ethical or continues to be involved in human affairs.
Jews don't have this doubt because about 2 million Jews experienced the miraculous exodus from Egypt,
followed by the theophany at Mount Sinai.
(Note that in all other religions, only the founder experienced a revelation).
The Jews passed this experience/tradition from father to son for the past 3400 years.
Also <i>Torah</i> scrolls have a life of about 1000 years.
They are meticulously copied using checksum-like techniques for verification.
The two oldest codices in existence today, both about 1000 years old, one from Leningrad and the other from Allepo
- a distance of 3500km, differ by only a single letter out of 600K letters!
</li>
<li>For a Jew, the positive and negative commandments are enumerated in detail in the <i>Torah</i> - both written and oral.
The term "Ten Commandments" is actually a misnomer. In fact they are the 10 <i>categories</i> of laws.
</li>
<li>For a non-Jew, his positive and negative commandments are far less encompassing which are specified in the oral law.
His obligations are called the <a href="https://en.wikipedia.org/wiki/Seven_Laws_of_Noah">7 Noachide laws</a>
which is also a misnomer, and should be more properly referred to as categories.
</li>
<li>Judaism recognizes that Man is not an angel. Man is made of flesh and blood.
No man is perfect, <i>but every man can strive for perfection</i>.
Therefore this belief in responsibility and accountability for one's actions does
not preclude the possiblility of repentance (Hebrew: <i>Teshuva</i>),
where God can forgive a man provided that he sincerely admits and regrets his past sins,
makes reparations when he sinned against a fellow man, and changes his future actions for the better.
</li>
</ul>
</li>

<li id="music-composition-footnote">My daughter Carmiella is a classical musician, a cellist, who was unfamiliar with music composition software.
I wrote the following example <a href="music/sf4.mp3">composition</a> for her. Here is the <a href="music/sf4.pdf">formatted score</a>,
and here is the <a href="music/sf4.abc.txt">original source</a> in <a href="https://en.wikipedia.org/wiki/ABC_notation">abc notation</a>.
Not being a programmer, my daughter found abc notation to be too "clunky" for her tastes;
but she progressed to become a regular user of the GUI composition software, the free open source <a href="https://musescore.org/">MuseScore</a>,
in which she has become proficient.
I too find that abc notation has rough edges.
I am considering writing a preprocessor for it that would make it more user friendly,
including a mode to use scale notation (i.e. <i>do, re, me, ..., ti</i> or I,II,...,VII) and relative octaves (e.g. <i>do+</i> and <i>do-</i>) instead of absolute notes (i.e. A, A#, B, C, C#, ...).
I feel that scale notation makes it much easier to describe the music theory techniques used in a composition.
</li>

</ol>

<h2 tabindex="0" id="epilogue">--</h2>
<p>
<address>
<a href="http://www.w3.org/TR/WCAG20/">WCAG</a> blind accessibility conformance:
This document contains text alternatives for images. It is tab navigable - for sections, subsections, paragraphs, list items, and links.
It is designed to be readable by the <a href="https://en.wikipedia.org/wiki/Lynx_(web_browser)">lynx</a> text based, i.e. non-GUI, web browser
- except for email and telephone number fields protected from <a href="https://en.wikipedia.org/wiki/Email_address_harvesting">anti-harvesting</a>.

<br>Safety &amp; non-annoyment pledge: This document is free of scripts, frames, ads, and animations
- except for the <a href="https://en.wikipedia.org/wiki/Google_Analytics">Google Analytics</a> tracker.
(This pledge was originally coined by <a href="https://davidpogue.com/">David Pogue</a>).

<br>Copyright &copy; 2017 Avraham Bernstein, Jerusalem ISRAEL. All rights reserved.

<br>Licenses: Except where otherwise noted, this work is licensed under the
Creative Commons License <a href="http://creativecommons.org/licenses/by-nd/4.0/">CC BY-ND 4.0</a>.
And except where otherwise noted, all source code included in this file
is licensed under the <a href="https://opensource.org/licenses/Apache-2.0">Apache License Version 2.0</a>.
</address>

<figure>
<img title="CC BY-ND 4.0" alt="CC BY-ND 4.0" src="http://purl.org/Avraham.Bernstein/resources/cc-by-nd.png" />
<figcaption>CC BY-ND 4.0</figcaption>
</figure>

</body>
</html>
