{# !!! SYNTAX GOTCHYAS !!!
1. We are using default delimiter sequences for begin and end tags,
i.e. {-{ ... }-}, {-% ... %-}, and {-# ... #-}.
for variable expressions, control statements, and comment statements respectively.
2. Note that in this multi-line comment section we add a '-' between the delimiters,
otherwise J2 cannot process this comment correctly.
3. But we are using *non-standard* '%-%' and '%-#' for the line statement prefix and line comment prefix respectively,
in order not to conflict with pandoc ATX headers '#' and automatically numbered lists '#.'.
4. Note that *sometimes* we find that the line statements eat all blank lines following it,
so sometimes it is necessary to terminate a sequence of line statements with an innocuous {{NL}}.
5. Internal pandoc link anchors, i.e. '{ #myanchor }' must have a space between the left brace and the hash,
otherwise they will conflict with J2 comments.
6. Use of the '@' character that immediately precedes a new word triggers a pandoc citation.
I don't know how to turn off the facility. So escape them as follows with a backslash, i.e. '\@'.
7. The current Python2 version of J2 does not support UTF-8 or Unicode,
so make sure the document is written in ISO-8859-1.
#}

# {{TITLE}} { #top }

%% if AGENT_NAME is defined
%% if WRITER == 'html5'
<span style="font-size:larger;background-color:#FFFF00;">
%% endif
__Represented by [{{AGENT_NAME}}]({{AGENT_URL}})__

%% if WRITER == 'html5'
</span>
%% endif
%% endif

_Version: {{VS}}_
{{BR}}_Last update: {{TS}}_
{{BR}}_{{COPYRIGHT}}_
{{BR}}_{{LICENSE}}_

{% if FULL %}
{% if WRITER == 'html5' %}
<figure>
<img title="{{NAME}}" alt="{{NAME}}" src="{{IMAGE_URL}}">
<figcaption>Secure[^secure-photo] photo of the author, {{NAME}} c. 2010.</figcaption>
</figure>
{% else %}
![Secure[^secure-photo] photo of the author, {{NAME}} c. 2010.]({{IMAGE_URL}})
{% endif %}

[^secure-photo]: This secure photo was built using an [oilify](http://docs.gimp.org/en/plug-in-oilify.html) filter and a visible email address [watermark](https://en.wikipedia.org/wiki/Digital_watermarking). It uses [digital camouflage](https://io9.gizmodo.com/5510040/designer-reverse-engineers-face-detection-tech-to-develop-camouflage-makeup) that will defeat almost all face matching algorithms - in spite of the fact that my 3 year old grandson has no problem identifying me from this photo. It protects my privacy in two ways. (1) Harvesting it from the Internet, and adding it to a database of photos that will be compared with CCTV surveillance photos will not work. (2) The photo has built-in [two factor authentication (2FA)](https://en.wikipedia.org/wiki/Multi-factor_authentication). The prominent email address watermark prevents a web site from maliciously displaying my photo while attempting to associate/label it with any other name besides mine. Similarly if a site were to maliciously display my photo without my permission in order to imply my association or agreement with them, then it is trivial for anyone who may be suspicious of their claim to "challenge" the site by asking me for a verification email.
{% endif %}


### 0.1 Contact Info & Links { #contact-info }

%# pandoc bug: thinks 'email/skype:' is a link
__email/skype\:__ [{{EMAIL}}](mailto:{{EMAIL}})
{{BR}}__geolocation:__ [{{CITY}} {{COUNTRY}}]({{GEO_URL}}), __tz:__ UTC +02:00/+03:00 \[winter/summer]
{{BR}}__tel-IL-mobile/whatsapp:__ {{TEL_IL_OBF}}
{{BR}}__tel-US-mobile:__ {{TEL_US_OBF}}
%% if FULL
{{BR}}__www-home:__ [{{HOME}}]({{HOME}})
{{BR}}__linkedin:__ [{{LINKEDIN_URL}}]({{LINKEDIN_URL}})
%% endif
{{BR}}__cv-full:__ [HTML]({{CV_HOME}}cv.html), [DOCX]({{CV_HOME}}cv.docx), [PDF]({{CV_HOME}}cv.pdf)
%% if FULL
__[this file]__
%% endif
{{BR}}__cv-abbrev:__ [HTML]({{CV_HOME}}cv-abbrev.html), [DOCX]({{CV_HOME}}cv-abbrev.docx), [PDF]({{CV_HOME}}cv-abbrev.pdf)
%% if ABBREV
__[this file]__
%% endif
{{NL}}


%% if FULL
### 0.2 Table of Contents

{{TOC}}
%% endif
{{NL}}


## 1.0 Summary

I am an experienced computer scientist and S/W architect. I have devised innovative solutions to many S/W problems for a wide range of fields, including

* cybersecurity
* cryptography
* bioinformatics
* factory automation
* VLSI CPU design
* telecommunications
* blind vision
* accessibility
* transportation vehicle route guidance
* automated testing

I have worked for a number of organizations, large and small, and helped them realize improvements in their product performance, often putting them in the front rank in their field. I have acquired expert knowledge in a number of fields, often liaising with noted experts, and have been able to quickly apply this knowledge to improve the competitive position of the companies and their products. I have a keen interest in computer languages, both practical and theoretical. I have created a number of [domain specific languages (DSL)](https://en.wikipedia.org/wiki/Domain-specific_language) that were instrumental in greatly simplifying seemingly intractable problems.

In order to understand how I design S/W see the following appendices:

* [Programming Language Preferences and Musings](#appendix-programming-languages)
* [Domain Specific Languages](#appendix-dsl)
* [How To Write Correct, Maintainable, Secure, and Easy-to-Test Code](#appendix-programming-testable)


## 2.0 Work Experience

%% macro DETAILS(id)
{% if ABBREV %} See [details]({{CV_HOME}}/cv.html#{{id}}).{% endif %}
%% endmacro

%% macro JOB(id,title,company,details_flag=true)
{{NL}}###{% if ABBREV %}#{% endif %} {{title}} { #{{id}} }

_\@{{company}}:_{% if details_flag %}{{DETAILS(id)}}{% endif %}
%% endmacro

%% set KEYS = BR + 'Keys:'


{{ JOB(
	'self-employed',
	'2017-present: Cybersecurity Consultant',
	'Self-Employed, Jerusalem',
	false
) }}
{{KEYS}} cybersecurity, architect, algorithms, obfuscation, compiler, {{HI('C/C++')}}, javascript, WASM

#. I am developing an [obfuscating](https://en.wikipedia.org/wiki/Obfuscation_(software)) [compiler](https://en.wikipedia.org/wiki/Compiler) for C/C++ and for [Web Assembly (WASM)](http://webassembly.org/). Still in stealth mode.
#. I am a security mentor for the Jerusalem [Mass Challenge](http://israel.masschallenge.org/) start-up hub.


{{ JOB(
	'viaccess',
	'2011-17: S/W Architect & Developer: Cybersecurity: OTT Internet Pay TV System',
	'Viaccess-Orca, Ra\'anana - a subsidiary of Orange FR, and \@Discretix/SansaSecurity, Netanya - now merged into ARM',
	false
) }}
{{KEYS}} cybersecurity, DRM, architect, algorithms, anti-reverse engineering, obfuscation, LLVM compiler, cryptography, {{HI('C/C++')}}, TCL, Python, bash, Android root detection, Linux, ELF edit, IOS

#. I architected and implemented anti-reverse engineering and [obfuscation](https://en.wikipedia.org/wiki/Obfuscation_(software)) programming frameworks and libraries in C/C++ for their [DRM](https://en.wikipedia.org/wiki/Digital_rights_management) protected movie player application that ran on Android and IOS devices.
#. The challenges of implementing obfuscation are that (1) the other programmers should not be concerned about it because their focus must be on writing correct code, and (2) the resulting increase in size and reduction in run-time speed must not noticeably reduce the usability/functionality of the application. In general the aim of obfuscation is to provide "good enough security" that will deter 95% of potential attackers, and when combined with regular application updates will force an attacker to begin his next reverse engineering attempt from scratch.
#. I developed a post processor to obfuscate the resulting binary object ELF files.
#. I developed a light weight obfuscated cryptographic library implemented as a H file using `inline` functions so that every module that included it had its own private copy of the library with a module specific randomized implementation which prevented an attack against a single core cryptographic module that could potentially subvert the whole application.
#. I developed an Android root detection mechanism using fuzzy logic techniques.
#. I developed a background watchdog security thread to dynamically ensure that the binary code had not been tampered with.
#. All secure code modules were implemented as native libraries written in C/C++.
#. Offline utilities and build scripts were written in bash, Python, and TCL.
#. My typical development methodology was to first build a prototype for desktop Linux, secondly as a standalone [CLI](https://en.wikipedia.org/wiki/Command-line_interface) application on the target device, and finally to incorporate the source code into the full application on the target device. Whenever possible I preferred to test on virtual machines.
#. I was responsible for the purchase decisions and usage policy of 3rd party obfuscation and cryptographic utilities and libraries.
#. {{HI_BEGIN}}At the end of my 6 year tenure there were 40M subscribers, and no security breaches.{{HI_END}}


{{ JOB(
	'cybersec-anonymous',
	'2016-16: Cybersecurity Consultant: Protection of a Small Business with Extremely High Security Concerns',
	'Anonymous, Jerusalem'
) }}
{{KEYS}} cybersecurity, privacy, anonymity, WordPress, static web site, Cloudflare, Windows, Android, Google Docs, Google Drive

%% if FULL
The client publishes a web site that "outs" (i.e. exposes) terrorists. Their WordPress web site was regularly attacked. And for personal safety reasons, their management and researchers needed to remain anonymous. Their enemies were well funded NGOs and government sponsored organizations. Their original web site developers were not cybersecurity aware, and their researchers who often worked remotely (i.e. outside of the office) were typical computer users who were naive about cybersecurity and how to protect their anonymity. After doing an initial risk assessment, my task was to implement graduated policies that improved their security without causing an upheaval to the way they worked.
%% endif


{{ JOB(
	'telequest',
	'2010-11: S/W Architect & Developer: Transportation: Urban Traffic Vehicle Route Guidance Algorithms',
	'TeleQuest, Jerusalem'
)}}
{{KEYS}} urban vehicle route guidance, architect, algorithms, Java, AWS

%% if FULL
I designed and implemented algorithms along with a computational infrastructure for urban traffic vehicle route guidance similar to what [Waze](https://www.waze.com/) does today. I implemented in Java. I implemented the simulation infrastructure on the cloud on [AWS](https://aws.amazon.com/). The Java implementation challenge was cost efficiency because the simulations used huge amounts of RAM and ran continuously for days on expensive servers. I could not rely on the efficacy of the built-in memory garbage collector (GC), so I had to explicitly coerce memory allocations and frees.
%% endif


{{ JOB(
	'syntezza',
	'2009-09: S/W Architect & Developer: Bioinformatics: PCR Algorithm',
	'Syntezza, Jerusalem'
) }}
{{KEYS}} bioinformatics, PCR, architect, algorithms, mathematical programming, {{HI('C')}}, Python

%% if FULL
#. The client's product was a [PCR](https://en.wikipedia.org/wiki/Polymerase_chain_reaction) (= DNA amplification technology) kit for detecting  [MRSA](https://en.wikipedia.org/wiki/Methicillin-resistant_Staphylococcus_aureus) (= an often lethal staphylococcus bacteria that is antibiotic resistant and thrives in hospitals) .
#. Within 3 months of joining the company and quickly learning the basics of bioinformatics via mentoring from a world renowned expert, [Dr. Tzachi Bar](https://scholar.google.co.il/citations?user=XokRoVQAAAAJ&hl=en), I discovered a new algorithm for overcoming [PCR inhibition](https://en.wikipedia.org/wiki/Polymerase_chain_reaction_inhibitors) using Artificial Intelligence (AI) and Data Science techniques where too much sample "noise" prevents the result of the biological assay from being estimated by the classic sigmoidal shaped [logistic  function](https://en.wikipedia.org/wiki/Logistic_function).
#. I implemented the final algorithm in C, while I built the prototype in Python using the [Numpy](http://www.numpy.org/), [Scipy](https://www.scipy.org/), and [Matplotlib](http://matplotlib.org/) packages.
#. {{HI_BEGIN}}When I started the project, the client's kit had only a 50% detection rate due to inhibition problems associated with their _preliminary_ chemistry that could not separate the DNA from the mucus in the nasal samples. This result was grossly unacceptable for any medical test. The investors had lost confidence, and were about to pull out. I improved the test's accuracy to 95%, which was 10% better than their competitors from the pharmaceutical giants. I saved the client from liquidation.{{HI_END}}
#. I am in the process of [patenting](#patents) my algorithm.
%% endif


{{ JOB(
	'nds',
	'2004-09: Cybersecurity Researcher for a CA Satellite Pay TV System',
	'Cisco-NDS, Jerusalem'
) }}
{{KEYS}} cybersecurity, DRM, algorithms, cryptography, anti-reverse engineering, obfuscation, LLVM compiler, VM, QEMU, RPC, automated testing, S/W quality, {{HI('C/C++')}}, TCL, Python, Linux, bash, Win32

%% if FULL
#. I worked on a wide variety of security related projects. My background task was to do C/C++ [code security reviews](https://www.securecoding.cert.org/confluence/display/seccode/Top+10+Secure+Coding+Practices). Typically secure coding is achieved by [adhering to best programming practices](https://www.youtube.com/watch?v=eL5o4PFuxTY).
#. I was a member of the architecture team for their in-house [LLVM](https://llvm.org/) [obfuscating](https://en.wikipedia.org/wiki/Obfuscation_(software)) C/C++ compiler.
#. I developed techniques using Virtual Machine (VM) technology to crack [Digital Rights Management (DRM)](https://en.wikipedia.org/wiki/Digital_rights_management) schemes, and to subvert the random number generators which are the core initialization process for all cryptographic algorithms. I implemented these techniques by hacking the open source [QEMU](https://www.qemu.org/) VM emulator written in C.
#. I wrote the technical specification for CCTV (Chinese government TV) to secure the TV feed of the 2008 Beijing Olympic broadcasts against international piracy. We almost won the contract, except Microsoft offered to do it for free.
#. I architected and implemented a hybrid simulator/emulator debugger written in C for legacy [Set-Top Boxes (STB)](https://en.wikipedia.org/wiki/Set-top_box) that originally could be debugged only with `printf` statements to log files. My new debugger allowed source code on the PC to be debugged using the [MS Visual Studio IDE](https://en.wikipedia.org/wiki/Microsoft_Visual_Studio) debugger while still viewing the results on the STB. Implementation was accomplished by reverse engineering of the STB middleware API. 80% of the middleware ran natively on the PC, while the STB low level H/W specific portions were implemented via an agent on the STB that was accessed via API calls that were implemented as [Remote Procedure Calls (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call).
#. I wrote an automated testing system in TCL and C/C++ for a satellite content delivery system for huge content, e.g. delivering ultra high definition movies to cinemas, and print newspapers for remote publishing. I created a [Domain Specific Language (DSL)](https://en.wikipedia.org/wiki/Domain-specific_language) in order to execute the satellite operations. After studying the Win32 C/C++ source code of the satellite ground control station, I detected a major conceptual flaw which the architect refused to believe (because testers are not supposed to understand Win32 internals!). So I wrote a progressive test that brought the satellite to its knees at only 25% of its rated capacity. Afterwards the development team used my tool to develop their own unit test scripts, and to execute a system sanity test before checking-in any changes to the source control system.
#. I did a study for senior management by data mining the company's bug database, which showed them that 25% of S/W development manpower was wasted on fixing bugs. And I presented them with simple techniques that could reduce this number by 80%.
%% endif


{{ JOB(
	'virtouch',
	'2002-03: S/W Architect & Developer: Accessibility: Enabled Blind to "See" Maps',
	'Virtouch, Jerusalem'
) }}
{{KEYS}} accessibility, blind, architect, GIS, MapML, HTML, SVG, javascript, XSLT, XML Schema, XSLT, {{HI('C')}}, TCL

%% if FULL
#. I was the inventor, architect, and main developer of a system that allowed the blind to to "see" geographic maps and digital images that were prepared using industry standard [GIS](https://en.wikipedia.org/wiki/Geographic_information_system) map descriptions such as [MapML](https://maps4html.github.io/MapML/spec/).
#. Maps were displayed on a standard HTML browser using HTML, SVG, javascript, XSLT, combined with audio feedback.
#. A touch tablet and stylus were used instead of a mouse because the blind can use a touch tablet much more effectively to navigate the screen compared to a mouse. The blind have their own sense of hand-eye coordination, and intuitively understand the stylus position on the tablet.
#. The core design principles were the following:
	* When the mouse/stylus hovers over a pixel or clicks on a pixel (depending upon its mode of operations), the pixel will be conveyed in 3 different sonic dimensions.
	* The x and y axis are divided into a uniform grid of 72x72 corresponding to a 6 octave 12 note chromatic scale per axis.
	* The x axis is associated with the first instrument say a piano, while the y axis is associated with the second instrument say a flute, so pixel position is conveyed via playback of 2 simultaneous notes.
	* Normally volume is associated with the 8-bit gray value of the pixel.
	* Reduce clutter by allowing the user to dynamically select which map layers to view. Typically visual maps display multiple layers simultaneously. Usually blind users cannot handle viewing multiple layers at once.
	* Allow the user to dynamically select the level of feature granularity that he wants to view. Think of a topographical map that has an isoline granularity of 100 meters. A blind user may be more comfortable changing the isoline granularity to 500 meters.
	* Depending upon the mode of operation, the rectangular touch tablet can be mapped into the whole rectangular screen, or into a rectangular window on the screen. The blind very quickly intuitively understand this type of mapping.
	* Take advantage of SVG's seamless zooming capability.
#. Maps and images were prepared offline using [XML Schema](https://en.wikipedia.org/wiki/XML_Schema_(W3C))
along with TCL preprocessing.
#. Note that this application required no custom H/W unlike their expensive (~$300) [VTPlayer tactile mouse](http://www.avrahambernstein.com/resources/vtplayer.png).
#. {{HI_BEGIN}}I _almost_ saved the company from liquidation. My research was awarded a European FP6 grant of $0.5M Euro that required _matching funds_. But the investors refused to put up the matching funds due to the company's long history of financial failure in the children's Braille education market using their expensive tactile mouse.{{HI_END}}
%% endif


{{ JOB(
	'vyyo',
	'1999-2002: S/W Architect & Developer: Network: Utilities for a "Wireless" Cable Modem and Router System',
	'Vyyo, Jerusalem'
) }}
{{KEYS}} network, architect, algorithms, SNMP, SNMP-agent, NMS, automated testing, {{HI('C')}}, TCL, embedded

%% if FULL
#. I was the architect and designer of the [SNMP](https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol) network management system (NMS), [MIB](https://en.wikipedia.org/wiki/Management_information_base), and embedded SNMP agent. The workstation NMS was implemented in TCL, and the embedded SNMP agents on the cable modem and router were implemented in C.
#. I was the architect and designer of a hybrid IP connection for cable modems where there was no physical cable upstream channel. Instead the upstream channel used a telephone modem (ATA), while the downstream channel used the cable modem. Head end network equipment for both interfaces was supplied by the cable operator. My solution was to dynamically modify the [arp table](https://en.wikipedia.org/wiki/Address_Resolution_Protocol) of the [edge router](http://searchnetworking.techtarget.com/definition/edge-router). For typical surfing, the effective downstream rate was as fast as a pure cable solution. The server implementation was in TCL, and the embedded cable modem implementation was in C. The company applied for a provisional patent.
#. I greatly improved the efficiency of the laboratory modem speed stress testing by a factor of 10-100 by using a [steepest descent](https://en.wikipedia.org/wiki/Gradient_descent) search algorithm instead of a binary search algorithm. Reduced testing time per modem from hours to minutes.
#. I designed a virtual testing lab with 64K modems and 512K PCs via multiplexing the physical connections. The test lab had only 256 physical cable modems, 4 physical PCs with 8 network connections each, 1 cable router, and 2 24-port layer-2 programmable switches. By dynamically editing the PC MAC addresses, and by dynamically editing the MAC filters on the network switches, I was able to fool the router into believing that it faced 64K modems, and to fool the modems into believing that each one was shared by 16 PCs. The Linux workstation implementation was in TCL and C.
#. I implemented a very efficient [hash table](https://en.wikipedia.org/wiki/Hash_table) algorithm in C for the router's [arp table](https://en.wikipedia.org/wiki/Address_Resolution_Protocol) cache, based upon an algorithm I had invented 10 years earlier. The special features of the hash table algorithm were no use of dynamic memory allocations for embedded safety, a unique 2^N table size algorithm that required no use of division or modulo operations for efficiency, and a LIFO queue in order to gracefully handle table overflow.
#. I developed a flash memory file system for the modem and router in C.
#. I developed a [TLV](https://en.wikipedia.org/wiki/Type-length-value) configuration file utility both offline for the PC workstation, and embedded on the modem and router in C and TCL.
%% endif


{{ JOB(
	'jolt',
	'2001-01: S/W Architect & Developer: Network: Network Management System (NMS) for a FSO Device',
	'MRV-Jolt, Jerusalem'
) }}
{{KEYS}} network, architect, SNMP, SNMP-agent, NMS, Java, {{HI('C')}}, TCL

%% if FULL
#. The client's product was a [free space optics (FSO)](https://en.wikipedia.org/wiki/Free-space_optical_communication) repeater that enabled fiber optic cables to be extended through the air via lasers for distances of up to 5 km.
#. These devices were made of digital H/W with no need for a CPU.
#. In order to provide them with [SNMP](https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol) network management capability, I selected an inexpensive micro-controller that could
interface with the FSO H/W, had an Ethernet port, and a built-in Java interpreter.
#. I designed the [MIB](https://en.wikipedia.org/wiki/Management_information_base), and an Java program that could interface with the H/W.
#. I implemented a simple HTTP server on the board that acted as an [SNMP proxy agent](http://www.mg-soft.com/mgSnmpProxyAgent.html).
#. I wrote a CLI utility in TCL and C using the open source [Net-SNMP](http://net-snmp.sourceforge.net/) framework to illustrate their SNMP compatibility to their customers.
%% endif


{{ JOB(
	'foxcom',
	'2001-01: Consultant: Network Management System (NMS) for a Cable Modem & Gateway System',
	'Foxcom - One Path Networks, Jerusalem'
) }}
{{KEYS}} SNMP, NMS

%% if FULL
{{HI_BEGIN}}I performed a one week requirements study in order to select the most appropriate NMS infrastructure for their needs. I saved them over $200K compared to their original selection.{{HI_END}}
%% endif


{{ JOB(
	'zamir',
	'2000-01: S/W Developer: Communications: Win32 Asynchronous TCP/IP DLL for a Visual Basic Project',
	'Inex-Zamir, Jerusalem'
) }}
{{KEYS}} TCP/IP communications, {{HI('C')}}, Visual Basic, Win32, soft real-time

%% if FULL
#. The client's product was a vehicle license plate reader for their own camera controlled parking systems, and as an OEM component that they sold to operators of camera controlled toll roads.
#. They developed their parking system in Visual Basic (VB) on Windows PCs.
#. They came to me because they needed asynchronous network communication capabilities, even though VB is inherently single threaded.
#. I wrote a Win32 DLL in C for the client, and helped them to modify their VB code so it could incorporate asynchronous communications.   
%% endif


{{ JOB(
	'fourfold',
	'1998-99: S/W Architect & Developer: Compiler: GCC Compiler Port for a 128-Core Stack Machine',
	'Fourfold, Jerusalem'
) }}
{{KEYS}} C compiler, gcc, architect, FORTH, {{HI('C/C++')}}, TCL, LISP

%% if FULL
#. This was a very challenging [gcc](https://gcc.gnu.org/) port because the architecture had no registers, or alternatively an infinite number of registers, while RAM access was highly unusual in order to accommodate the 128 cores.
#. The machine instruction set was [FORTH](https://en.wikipedia.org/wiki/Forth_(programming_language))-like, so it presented unusual optimization challenges, because it was so unlike the standard [CISC](https://en.wikipedia.org/wiki/Complex_instruction_set_computer) and [RISC](https://en.wikipedia.org/wiki/Reduced_instruction_set_computer) instruction sets.
#. I noted early in the project that the method for emitting target object code was well suited to an object oriented design, even though at the time the gcc compiler collection only interfaced with C code. In order to lower the "impedance" of using C++, I created a static "wrapper" for the C++ classes that could interface to the C code that the gcc compiler development framework generated.
#. The final source code was extremely repetitive. Therefore I developed a preprocessor in [TCL](https://en.wikipedia.org/wiki/Tcl) in order to automatically generate much of the code.
#. The resulting C compiler worked and produced efficient code.
%% endif


{{ JOB(
	'optimet',
	'1997-98: S/W Architect & Developer: Factory Automation: Conoscopic Interferometer Workstation',
	'Newport-Optimet'
) }}
{{KEYS}} measurement workstation, architect, DSL, {{HI('C')}}, TCL, OpenGL, Win32, soft real-time

%% if FULL
#. The client's product was a measurement workstation based upon their [conoscopic](http://www.optimet.com/faq.php) probe.
#. The object to be measured was placed on a static platter, while the scanning probe could be moved in the XY axes above the platter. The probe measured Z distance.
#. The workstation also included a video camera.
#. Generally the probe would scan at its maximum speed, although some types of materials, especially reflective, required lower speed.
#. My task was to design the S/W architecture for a Windows NT PC to implement an _automated_ workstation that could be used in a factory environment.
#. I created a [domain specific language (DSL)](https://en.wikipedia.org/wiki/Domain-specific_language) implemented in TCL and C for controlling and configuring the workstation.
#. The most interesting and challenging aspect of the project was to give "life", i.e. semantic meaning, to the millions of raw XYZ data points that were measured.
#. I used [OpenGL](https://en.wikipedia.org/wiki/OpenGL) for rendering graphics. I created a toolkit and domain specific language for the 3D visualizations - unfortunately just _before_ the initial release of [VTK](http://www.vtk.org/).
%% endif


{{ JOB(
	'mer',
	'1996-97: Lecturer: Win32 Internals Course',
	'M.E.R., Jerusalem',
	false
) }}
{{KEYS}} lecturer, Win32


{{ JOB(
	'ultramind',
	'1996-96: Consulting S/W Engineer: Win32 Improve Performance of a Soft Real-Time Biofeedback Application',
	'UltraMind, Jerusalem',
	false
) }}
{{KEYS}} Win32, soft real-time


{{ JOB(
	'cefar',
	'1996-96: Consulting S/W Engineer: Win32 Device Driver for a Frame Grabber',
	'Cefar, Jerusalem',
	false
) }}
{{KEYS}} Win32, soft real-time


{{ JOB(
	'elop',
	'1995-96: S/W Architect & Developer: US DOD Mil-Spec Automated Testing: Night Hawk Fire Control System',
	'Elbit-Elop, Rechovot'
) }}
{{KEYS}} automated testing, mil-spec, architect, DSL, {{HI('C/C++')}}, BASIC compiler, lex/yacc, Win32, soft real-time

%% if FULL
#. The client's project was the fire control system for the Night Hawk laser guided missiles.
#. My task was to create an architecture and implementation of the automated test procedures dictated by the US DOD. The test specification documentation was over 1 meter high.
#. Additionally there would be many _ad hoc_ tests that would be required during the development process.
#. The test equipment included external voltage regulators, external heating and cooling equipment, vibrators, etc.
#. The workstation controlling the tests was a Windows NT PC.
#. Instead of creating a monolithic test program in C/C++, I created a BASIC-like [domain specific language (DSL)](https://en.wikipedia.org/wiki/Domain-specific_language) with special C++ drivers for controlling the various pieces of H/W.
#. I implemented the BASIC compiler using [lex/yacc](https://en.wikipedia.org/wiki/Yacc) and C++.
#. I made this critical architectural decision because the test specification manual was being regularly revised, plus I needed the flexibility to allow the _non-programmer_ system engineers to write their own scripts without delving into the underlying C++ code. And I wanted to avoid having the client call me every time he needed to implement a minor/trivial change that he could easily learn to do himself.
#. The standard tests were presented via a UX which in fact emitted BASIC script.
#. The system worked as planned. Unsupervised tests ran successfully for up to 72 hours (over holidays).
#. Post mortem: The first version of [TCL](https://en.wikipedia.org/wiki/Tcl) was released just around the time of this project, i.e. _pre-Internet_. Once I learned about TCL, I immediately realized it would have been the ideal platform for creating the test environment. Instead of me having to create my own BASIC-like language with control structures and variable handling, I could have relied upon TCL, and simply added custom primitives for the various pieces of H/W.
%% endif


{{ JOB(
	'michlala',
	'1995-95: Lecturer: Introductory University Computer Science Course on Database Theory',
	'Michlala College Bayit Vegan, Jerusalem',
	false
) }}
{{KEYS}} lecturer, database, SQL


{{ JOB(
	'dspg',
	'1991-94: S/W Architect & Developer: VLSI: Simulator & S/W Toolchain For DSPG PINE CPU',
	'DSP Group, Givat Shmuel'
) }}
{{KEYS}} VLSI simulator, S/W Development Toochain, architect, DSL, {{HI('C/C++')}}, lex/yacc, assembly, Win32

%% if FULL
#. I was the S/W architect of a clock accurate DSP CPU simulator along with a complete software development toolchain, i.e. a debugger, C compiler, assembler and linker. Note that the system was developed just _before_ the GNU Compiler Collection framework reached maturity, i.e. v2.95.
#. {{HI_BEGIN}}This system enabled working applications to be developed before the chip became physically available. It reduced application time-to-market by 6-12 months.{{HI_END}}
#. The technological breakthrough was my design of a [domain specific language (DSL)](https://en.wikipedia.org/wiki/Domain-specific_language) that described the CPU architecture. Implementation was in [lex/yacc](https://en.wikipedia.org/wiki/Yacc) and C++.
#. The associated DSL compiler automatically generated the source code for the complete toolchain that enabled it be automatically rebuilt within an hour in the face of almost daily changes to the VLSI architecture - especially the pipeline.
#. {{HI_BEGIN}}And after every change to the architecture, we ran the complete suite of VLSI verification regression tests 100-1000 times faster than the VHDL simulator.{{HI_END}}
%% endif


{{JOB(
	'iscar',
	'1989-91: S/W Architect & Developer: Factory Automation: Shop Floor Production Control (SFPC) System: BARI II',
	'Digital Equipment Corporation (DEC), Herzliya, for \@Iscar, Tefen'
) }}
{{KEYS}} factory automation SFPC, architect, DSL, Pascal, SQL, VAX/VMS

%% if FULL
#. Iscar Matkash in Tefen IL is a fully automated factory that produces thousands of different cutting blades using a sintering process.
The raw materials go through many stages of operations.
In many cases after undergoing intermediate processing,
the partially processed material can still be diverted to multiple final products - similar to stem cells.
The factory contains hundreds of automated workstations, stands, stacks, guided vehicles, and conveyor belts.
The product or intermediate product is placed on pallets.
The pallets are moved from one stand on a workstation to a stand on another workstation, or temporarily to a storage stand or stack.
#. My task was to create a computer program that automatically operated/orchestrated the factory.
#. When my co-architect and I started this project, we had zero background in industrial engineering.
We were supplied with a mentor who brought us up to speed.
#. Eventually after months of discussions we created an architecture that was a textbook object oriented
taxonomy - a "factory object kingdom". The top level object was a "production instruction".
#. We defined the attributes and methods associated with each object.
#. We created a descriptive, i.e. _non-procedural_, [domain specific language (DSL)](https://en.wikipedia.org/wiki/Domain-specific_language) that was designed to be user-friendly for the factory engineer.
#. I wrote the language manual.
#. We used the language to configure the factory. We created a UX which emitted CLI script. But major updates to the database were implemented via very large CLI scripts of thousands of lines.
#. We mapped the language to a relational database.
#. We coded the system in Pascal. Given the inherent object oriented (OO) nature of the architecture, C++ would have been the ideal implementation language, but the project manager refused because he was not familiar with any OO languages.
#. After 18 calendar months, and 6 man-years later, the factory ran perfectly!
%% endif


{{ JOB(
'light-pen',
'1988-88: S/W Architect & Developer: Accessibility: Quadriplegic PC Accessibility',
'Cubital, Herzliya - a charity project funded by the company and their CEO [Itzhak Pomerantz](https://il.linkedin.com/in/itzhak-pomerantz-91500b3) in cooperation with the Beit Levinson Rehabilitation Hospital, and the IDF Rehabilitation Unit'
) }}
{{KEYS}} accessibility, Prolog, PC-DOS

%% if FULL
#. First of all, it important to note that this project took place in 1988 when speech recognition technology was still in its infancy, and exorbitantly expensive.
#. The H/W used for this project was the following:
	a. A [light pen](https://en.wikipedia.org/wiki/Light_pen), i.e. an obsolete pre-mouse point and click device that synchronizes with the trace signal of the CRT video display, outfitted with special light weight military optics that increased its effective range from 5 mm from the screen to 800 mm.
	b. A standard accessibility [sip-and-puff](https://en.wikipedia.org/wiki/Sip-and-puff) switch.
#. The light pen was mounted on the user's head by using a sturdy woman's plastic hair head band, while the sip-and-puff straw replaced the button on the light pen.
#. The S/W that I developed overlaid a virtual keyboard on top of the screen.
#. In novice mode aiming the pen at a key caused it to illuminate, while clicking on it entered it into the system as a virtual key stroke.
#. The problem with novice mode was that the virtual keyboard obstructed more than half the screen.
#. In expert mode, the virtual keyboard was hidden, but when the pen was aimed at an individual key, it would pop-up and become illuminated.
#. {{HI_BEGIN}}This system was used to enable Shulamit Gabbai, a former school teacher who became quadriplegic by contacting polio (due to a terrible malfunction in the *Or Akiva* drinking water supply which became mixed with sewage), to become a book editor for *Maariv*. She was able to type 30 characters per minute.{{HI_END}}
%% endif


{{ JOB(
	'cubital',
	'1987-88: S/W Developer & VAX/VMS Sysadmin: 3D Printer: Solider',
	'Cubital, Herzliya'
) }}
{{KEYS}} 3D printing, {{HI('C')}}, sysadmin, VAX/VMS

%% if FULL
#. Solider was one of the first 3D printers. It was the size of a shipping container, but it embodied the same principles used in modern 3D desktop printers.
#. Since a 3D printer prints one layer at a time, conceptually it is similar to the way a regular printer prints one page at a time, so I designed a VAX/VMS print driver for the 3D printer in C.
%% endif


{{ JOB(
	'elde',
	'1986-87: S/W Developer: Soft Real-Time RS232 Z80 Communication Driver: Data Collection & Access Control Terminal',
	'Elde, Jerusalem',
	false
) }}
{{KEYS}} data collection terminal, {{HI('C')}}, RS232, Z80, embedded, real-time


{{ JOB(
	'orisol',
	'1985-86: S/W Developer: Factory Automation: Leather Sewing Workstation',
	'Orisol, Lod'
) }}
{{KEYS}} sewing workstation, DSL, AutoCad, {{HI('C')}}, awk, PC-DOS

%% if FULL
#. This is the first time I developed a [Domain Specific Language (DSL)](https://en.wikipedia.org/wiki/Domain-specific_language) in order to implement the sewing machine control program.
#. Note that leather is a natural product. Therefore no two pieces of leather are identical, so an automated sewing program must be intelligent in order to accommodate the shape of each unique piece of leather. The workstation included a video camera in order to enable real-time feedback.
#. The sewing machine had a maximum speed of thousands of stitches per minute which produced very high torque, so it had to be carefully controlled to slow down gradually in order not to damage the motor. Non-linear sewing paths required slower sewing speeds, while sharp turns required nearly a complete stop before taking the turn.
#. I added _annotations_ to the [AutoCad](https://en.wikipedia.org/wiki/AutoCAD) description of the pattern. These annotations included needle up/down, stitching speed, minimum and maximum margin widths, and image detection algorithm instructions according to the color and pattern of the leather.
#. I compiled the pattern and annotations into a [soft real time](https://stackoverflow.com/questions/17308956/differences-between-hard-real-time-soft-real-time-and-firm-real-time) control program implemented in C. I implemented the compiler in awk.
%% endif


{{ JOB(
	'john-bryce',
	'1984-85: S/W Developer & VAX/VMS Sysadmin: Hebrew/English Word Processor: Glyph',
	'John Bryce, Jerusalem',
	false
) }}
{{KEYS}} word processor, {{HI('C')}}, sysadmin, VAX/VMS


{{ JOB(
	'elta',
	'1983-84: S/W Developer: Real-Time: Data Collection Terminal & Lavi Fighter Plane Radar',
	'DSI, Givatayim for \@Elta/IAI, Ashdod'
) }}
{{KEYS}} data collection terminal, PL/M, 8080, RTOS, fighter plane radar, Jovial, embedded, real-time

%% if FULL
#. This was my first job upon making [Aliya](https://en.wikipedia.org/wiki/Aliyah) to Israel.
#. Before receiving my security clearance, I worked on the development of a data collection & access control terminal.
#. I wrote an [RTOS](https://en.wikipedia.org/wiki/Real-time_operating_system) kernel in __PL/M__ and __assembly__ for the __8080__ CPU because at the time no off-the-shelf alternative was available.
My mentor was Menachem Malkosh. It was a formative learning experience.
#. After receiving my clearance, I worked on the embedded radar S/W for the [Lavi fighter plane](https://en.wikipedia.org/wiki/IAI_Lavi) in [Jovial](https://en.wikipedia.org/wiki/JOVIAL).
%% endif


{{ JOB(
	'mitre',
	'1981-83: S/W Developer & IBM CP/CMS Assistant Sysadmin',
	'Mitre Corp, McLean VA'
) }}
{{KEYS}} APL, PL/1, sysadmin, IBM CP/CMS

%% if FULL
Most of my programming was in [APL](https://en.wikipedia.org/wiki/APL_(programming_language)). The APL [functional programming](https://en.wikipedia.org/wiki/Functional_programming) mathematical vector language is still a relevant paradigm to the present day.
%% endif


{{ JOB(
	'jwwa',
	'1979-80: Programmer & Economist',
	'JWWA.com, an economic consulting firm in the Washington DC area'
) }}
{{KEYS}} electric utility economics, Fortran, IBM MVS

%% if FULL
I configured computer simulations of electric power generating systems for the purpose of costing and pricing models that were used to present multiple scenarios at [Public Utilities Commission (PUC)](https://en.wikipedia.org/wiki/Public_utilities_commission) rate hearings. The simulation language was written in __Fortran__, and execution was on a IBM 370 mainframe remotely accessible via [WYLBUR](https://en.wikipedia.org/wiki/ORVYL_and_WYLBUR).
%% endif


{{ JOB(
	'oeb',
	'1977-78: Intervenor/Economist',
	'Ontario Energy Board (OEB), Toronto'
) }}
{{KEYS}} electric utility economics

%% if FULL
#. I was an [intervenor](https://en.wikipedia.org/wiki/Intervention_(law)) at the ECAP'77 costing and pricing hearings.
#. Like all citizens, I had legal standing because I paid an electric bill.
#. I took over the [marginal cost pricing](https://en.wikipedia.org/wiki/Marginal_cost) (= peak load or time-of-day pricing) proposal of the Ontario Hydro (i.e. at that time the name of Ontario's electric generation and transmission utility) economists who were forced to drop their case due to extreme political pressure from the metallurgy processing industry who at the time relied upon electric blast furnaces.
#. I actively participated in the hearing sessions for about 9 months. I filed submissions, gave expert testimony, and cross-examined opposing witnesses.
#. {{HI_BEGIN}}I argued my position very well. At 22 years old, I was the first public interest intervenor in the history of the OEB to be awarded costs.{{HI_END}}
#. {{HI_BEGIN}}I published an op-ed in [The Globe and Mail](https://www.theglobeandmail.com/), i.e. at the time Canada's newspaper of record, explaining the economic and political issues surrounding the case.{{HI_END}}
%% endif
{{NL}}

## 4.0 Education

### 4.1 Formal Education

#### 1979: York University, Canada: MA Economics & Applied Mathematics { #york-univ }

{{DETAILS('york-univ')}}
%% if FULL
I passed my final examinations in economic theory before I even started the program, so in order to achieve my required course credits the faculty agreed to allow me to be a special student at the Univ. of Toronto graduate faculty of engineering, where I took the majority of my courses. My major project was a computer simulation in __Fortran__ how to cost efficiently operate a hydro-electric dam. I was mentored by an economist from Ontario Hydro (i.e. at that time the name of Ontario's electric generation and transmission utility).
{% endif %}


#### 1977: University of Toronto - Rotman School of Management (MBA Program): No Degree { #univ-toronto-mba }

{{DETAILS('univ-toronto-mba')}}
%% if FULL
I "dropped out" of school in the middle of the year after taking an advanced micro-economic theory course which analyzed the Ontario Hydro [marginal cost pricing](https://en.wikipedia.org/wiki/Marginal_cost) submission to the [Ontario Energy Board (OEB)](#oeb) above, in order to take advantage of the unusual opportunity to present Ontario Hydro's case for them, which they were forced to drop for political reason. The following year I was able to apply my course credits to an MA Economics program at [York University](#york-univ) above.
{% endif %}


#### 1976: University of Toronto: BA Economics & Applied Mathematics { #univ-toronto-ba }

{{DETAILS('univ-toronto-ba')}}
%% if FULL
The most memorable and still useful courses I took were in statistics, experimental design, game theory, advanced calculus, and microeconomics.

{{HI_BEGIN}}In 1971 at the age of 15, for a high school computer science course, I wrote a computer program to play a perfect game of 3D 4x4x4 [tic-tac-toe](https://en.wikipedia.org/wiki/Tic-tac-toe) in __Fortran__ on an [IBM 1130](https://en.wikipedia.org/wiki/IBM_1130). The computer had 16 KB RAM, and was the size of a refrigerator. It was arguably my most formative learning experience from which I received the computer programming "bug" which I carry with me to the present day.{{HI_END}}
{% endif %}


### 4.2 Continuing Education

#. Today the field of computer science is changing so rapidly, that without ongoing self-study, one's formal education becomes obsolete within 5 years.
#. From 1991-96, pre-Internet, I used to spend one afternoon per week reading at the Hebrew University Jerusalem (HUJI) computer science library.
#. Afterwards with the advent of the Internet, more up-to-date computer science topics were available on the Internet, so going to the library was no longer the most efficient way to keep updated.
#. Since 2005, I have maintained a subscription to the [O'Reilly Safari](https://www.safaribooksonline.com/) on-line tech library.
#. My daily dose of tech news comes from [Slashdot](https://www.safaribooksonline.com/).
#. I regularly watch [TedX](https://www.ted.com/about/programs-initiatives/tedx-program) and [Talks At Google](https://talksat.withgoogle.com/) video seminars.
#. The most fascinating feature of TedX talks is to watch and learn how world class experts in a wide range of fields are able to distill their special area of knowledge to intelligent laymen in just 18 minutes. Whenever I make a presentation, I attempt to emulate the best TedX speakers. Also I attempt to write presentations which emulate this TedX [Art of Innovation Top 10 Format](https://www.youtube.com/watch?v=Mtjatz9r-Vc).
#. I regularly read the tech sections of the Israeli business newspapers [Globes](https://www.globes.co.il/en/) and [The Times of Israel](http://www.timesofisrael.com/start-up-israel/).
#. I have eclectic interests.
#. I regularly research new topics in depth.
#. My browser bookmarks are my most important professional store of my knowledge. I use Firefox because it has the best built-in bookmarking feature, because it uses tags/labels. I have a well honed tag taxonomy.
#. I am an [expert generalist](http://99u.com/articles/7269/picasso-kepler-and-the-benefits-of-being-an-expert-generalist), and an [autodidact polymath](http://autodidactpolymath.com/autodidact-polymath-definition/), i.e. a self-learner in new fields who achieves expertise quickly.


## 5.0 Spoken Languages

#. English (5/5)
#. Hebrew (4/5)
#. French (2/5)


## 6.0 Computer Languages, SDKs, and Operating Systems { #computer-languages }

Language knowledge in order of expertise, based upon my current frequency of usage:

#. C, TCL, bash + posix text utilities, e.g. awk, sed, etc.
#. C++, python, make, html5, css, markdown, pandoc, jinja2
#. flex, bison, llvm, javascript, java, yaml, json, go
#. forth, lisp, prolog, apl, fortran, opengl, svg, xml schema, relax ng, xslt, perl, C#


_Note that I write compilers and [Domain Specific Languages (DSL)](https://en.wikipedia.org/wiki/Domain-specific_language), so learning a new language takes me only a few days._

O/S knowledge in order of expertise, based upon my current frequency of usage:

#. Linux
#. Android
#. Win32
#. IOS


## 7.0 Patents Under Development { #patents }

* [Bioinformatics](https://en.wikipedia.org/wiki/Bioinformatics): (a) An extremely accurate and simple noise reduction and normalization algorithm to improve the accuracy of the standard [PCR Ct](http://www.thermofisher.com/il/en/home/life-science/pcr/real-time-pcr/qpcr-education/pcr-understanding-ct-application-note.html) calculation, and (b) an [Artificial Intelligence (AI)](https://en.wikipedia.org/wiki/Artificial_intelligence) methodology for measuring the quantity of DNA in a bioassay where [inhibition](https://en.wikipedia.org/wiki/Polymerase_chain_reaction_inhibitors) makes it impossible to estimate the Ct because no underlying [logistic function](https://en.wikipedia.org/wiki/Logistic_function) (= a flat "S" shaped curve) exists.

* [Cryptography](https://en.wikipedia.org/wiki/Cryptography): A set of non-linear cryptographic primitives using [Hamming weight](https://en.wikipedia.org/wiki/Hamming_weight)-like [data dependent permutations](https://link.springer.com/article/10.1007%2Fs00145-001-0012-9?LI=true) which overcomes the well known limitation of using Hamming weights because they have a [binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution).


## 8.0 Personal

I was born in Canada in 1956. I have lived in Jerusalem Israel since 1983. I am married with 4 children, 2B + 2G, plus many grandchildren. I take physical fitness seriously. Once upon a time I was a judoka, and a classical guitarist. I was an IDF reserve soldier for 15 years, where I served as a combat soldier in the infantry in the Jordan Valley. In spite of the fact that I joined the army when I was 32 years old (Hebrew: _Shlav Betnik_), functionally, but unofficially, I served in the capacity of deputy company commander (Hebrew: _Samech Mem Pe_) which provided me with the opportunity to achieve rich personal growth, and enabled me to learn important managerial and leadership skills.


## Appendix A: Programming Language Preferences and Musings { #appendix-programming-languages }

Because I have a strong background in compilers, I am knowledgeable in many computer languages, and I can learn a new language at an expert level very quickly.

My "go to" language for low level programming is C while still taking advantage of modern programming paradigms (i.e. [encapsulation](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)), [composition](https://en.wikipedia.org/wiki/Object_composition), and [interface](https://en.wikipedia.org/wiki/Protocol_(object-oriented_programming)) as opposed to [inheritance](https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming))).
The advantage of using C is that it is the universal interface language.

Where projects demand it, I can write C++ well too, but I am much more aware than the average programmer of its potential pitfalls, for example:

* brittle and [tightly coupled](https://en.wikipedia.org/wiki/Coupling_(computer_programming)) object hierarchies
* preference for inheritance when composition would suffice
* real-time limitations
* in general lack of [WYSIWYG](https://en.wikipedia.org/wiki/WYSIWYG) understandability of the source code due to use of complex inheritance hierarchies, operator overloading, cast operators, and exceptions.

However I find there is one class of application where I always prefer C++, namely when writing compilers and interpreters, because [abstract syntax trees (AST)](https://en.wikipedia.org/wiki/Abstract_syntax_tree) have a deep inheritance structure.


## Appendix B: Domain Specific Languages (DSL) { #appendix-dsl }

### B.1: DSL What and Why

First of all, here is the Wikipedia entry for [domain specific languages (DSL)](https://en.wikipedia.org/wiki/Domain-specific_language).

Consider a GUI calculator app.  It is not convenient to manually enter thousands of calculations. Similarly "fuzzing" the app, i.e. automatically testing it for corner conditions, will require that thousands of possibilities be tested. Most GUI apps are automatically tested by simulating low level UI events, e.g. mouse movement and button events, and individual key stroke events. These low level UI events have no semantic meaning _per se_. And if the UI layout were to change then a test program based upon UI events would have to redesigned. It would be much much easier to use this app for batch processing by starting off with all the data in a text file say in a simple CSV (spreadsheet) format. If the GUI calculator app were built to emit script acceptable to the venerable Linux `bc` CLI calculator app, then it would be trivial to automate it. And for a larger and more complex GUI app with lots of menus and dynamic dialog boxes, interpreting UI events is much more difficult.

Now consider the venerable Linux `gdb` debugger which has a built-in CLI. Most GUI debugger apps on Linux are in fact front ends for `gdb`. It is usually not too difficult to write a huge `gdb` script which can be used to fuzz individual functions inside a large executable program (as long as it is compiled with debug symbols).

In general an app's GUI should be a wrapper for the underlying app's CLI.
The GUI should emit CLI script.
This way it is easy to record user GUI events.
The app can be used in batch mode.
And it is straightforward to write an automated testing suite for the app.

When specifying an architecture for a large system, it is preferable to create a DSL that describes all aspects of how the system is supposed to behave.
This DSL formalizes the architecture, and provides the groundwork for automated testing.

The app's CLI should include end user definable control structures (i.e. condition and loop handling), along with the ability to define procedures, variables, and data structures.
Embedded language frameworks such as [FOSS](https://en.wikipedia.org/wiki/Free_and_open-source_software) [Lua](https://en.wikipedia.org/wiki/Lua_(programming_language)) and [FICL](http://ficl.sourceforge.net/) (i.e. an embeddable FORTH) provide this infrastructure for free.
In fact these relatively small frameworks, i.e. with a memory footprint of 50-100 KB, usually grossly simplify the CLI design.
Now an argument to a CLI method can take a numeric expression without the necessity of the programmer to understand anything at all about the complexity of writing a numeric expression parser.
The framework allows an end user to create his own macros, test conditions, and write loops.
An app with a CLI can be "glued" together with many other unrelated apps, just like the hundreds of Posix text utilities, and used in many unexpected but very useful ways - as opposed to a GUI-only interface which greatly limits how an app can interface with other apps.


### B.2: DSL How To

#### B.2.1: DSL Simple via Jinja2

Most languages have mediocre or non-existent generic, macro, and template facilities but I can get around these limitations by wrapping most any language using the superb [Jinja2](http://jinja.pocoo.org/) template/macro language as a preprocessor. Google uses Jinja2 in this way for its flagship [Chromium](https://www.chromium.org/developers/jinja) project. My first step before designing a full-fledged DSL is to determine whether or not Jinja2 can be gently coerced to do a good enough job.

For example, consider a long repetitive declarative configuration file, that could be greatly simplified and shortened by using Jinja2 templates.

Or consider the C language built-in [cpp macro preprocessor](https://en.wikipedia.org/wiki/C_preprocessor) which is very simplistic. It has no template support. There is no _pre-compilation_ support for arithmetic or string operations, array index selection, execution of O/S shell commands, and there is no straightforward way to implement loops, while complex macros with many levels of calls can often be incorrectly considered to be recursive which abort without even an error message. Once upon a time the [m4 macro processor](https://en.wikipedia.org/wiki/M4_(computer_language)) would be the tool of choice to implement complex macros. It has an arcane syntax, but it is admittedly Turing complete. Today very sophisticated Jinja2 macros and templates can be wrapped to look like cpp macros. This wrapping is important because most modern C/C++ IDEs have language sensitive editors that will choke when encountering invalid C/C++ syntax. Therefore the [Makefile](https://en.wikipedia.org/wiki/Makefile) implementation strategy is to first execute cpp (i.e. `gcc -E`), followed by Jinja2, followed by gcc.

The following is an example of a Jinja2 macro `J2_ABC` that executes a python function that can be declared in a C/C++ file, and will keep the language sensitive IDE happy. Because some IDEs with smart language sensitive editors interpret cpp macros during an editing session, there must be 2 modes of operation, (1) build mode that will emit Jinja2/Python code, and (2) IDE mode that will emit default syntactically valid C/C++ code.

~~~ { #jinja2-cpp .c }
// 1. Must not use j2 default expression delimiter, i.e. double braces, otherwise will conflict with C/C++ syntax.
// 2. Should not specify j2 delimiters *directly*, otherwise will cause documentation j2 preprocessing errors.
// 3. Should not use j2 line mode *mixed* with C/C++, even with modified delimiters say '%%' and '%''#'
// for control and comment statements respectively, because a language sensitive IDE will choke on the code.
// 4. However it can be an effective technique to include j2 source files that contain control statements
// that are protected with an *external* cpp guard:
//     #if J2_MODE == J2_MODE_BUILD
//     #include "my-macros.j2"
//     #endif

#define J2_MODE_IDE                0
#define J2_MODE_BUILD              1
#ifndef J2_MODE
#define J2_MODE                    J2_MODE_IDE // dflt allows seamless editing with a smart language sensitive editor
#endif

#if J2_MODE == J2_MODE_BUILD

#define J2_COM_DELIM               #   // comment statement delimiter
#define J2_CNTRL_DELIM             %   // control statement delimiter
#define J2_EXPR_DELIM              ^   // embedded expression delimiter

#define J2_CNTRL(...)              {J2_CNTRL_DELIM __VA_ARGS__ J2_CNTRL_DELIM}
#define J2_COM(...)                {J2_COM_DELIM __VA_ARGS__ J2_COM_DELIM}
#define J2_EXPR_2(ide_dflt_in_parens,...)  {J2_EXPR_DELIM __VA_ARGS__ J2_EXPR_DELIM}

#else // J2_MODE_IDE

#define J2_IDENT(...)              __VA_ARGS__

#define J2_CNTRL(...)
#define J2_COM(...)
#define J2_EXPR_2(ide_dflt_in_parens,...)  J2_IDENT ide_dflt_in_parens

#endif

#define J2_EXPR_EMPTY(...)         J2_EXPR_2((),   __VA_ARGS__)
#define J2_EXPR_ZERO(...)          J2_EXPR_2((0),  __VA_ARGS__)
#define J2_EXPR_ONE(...)           J2_EXPR_2((1),  __VA_ARGS__)
#define J2_EXPR_CHR(...)           J2_EXPR_2((''), __VA_ARGS__)
#define J2_EXPR_STR(...)           J2_EXPR_2((""), __VA_ARGS__)

#define J2_ABC(...)                J2_EXPR_ZERO(py_abc(__VA_ARGS__))
~~~


#### B.2.2: DSL Full-fledged

When writing a full-fledged DSL, unless run-time efficiency or a binary target is critically important, I tend to shy away from using formal compiler frameworks such as [flex/bison](https://en.wikipedia.org/wiki/GNU_bison), [ANTLR](http://www.antlr.org/), [LLVM](https://llvm.org/), etc., because they are complex and have a relatively steep learning curve.

In my experience most DSLs require a limited number of domain specific verbs and data structures. The rest of the language such as control structures (e.g. conditions and loops), and procedure, variable, and data structure definitions, which are by far the most difficult and time consuming to develop, can piggyback upon the built-in features of extensible languages such as [TCL](https://en.wikipedia.org/wiki/Tcl), [Python](https://en.wikipedia.org/wiki/Python_(programming_language)), [Lua](https://en.wikipedia.org/wiki/Lua_(programming_language)), [FORTH](https://en.wikipedia.org/wiki/Forth_(programming_language)), etc.

Where the implementation will be a standalone CLI, my first choice is to use TCL. And if the TCL app also needs a UX then the [Tcl/Tk](https://en.wikipedia.org/wiki/Tk_(software)) widget toolkit can be used to simply and quickly produce a GUI - admittedly not the most elegant, but usually good enough. However when third party packages are needed to support the language (e.g. mathematical, scientific, and AI libraries etc.) then Python is required. Admittedly there are at least 100 times more Python programmers than TCL programmers, so even though it usually requires significantly less code to create a standalone CLI app in TCL, from the client's perspective of future maintainability, it is often more cost effective to spend the extra initial effort to build the app in Python.

And where the implementation will be embedded inside another application then Lua is the easiest to understand for most end users, but where minimizing code footprint and maximizing execution speed are more important then [FORTH/FICL](http://ficl.sourceforge.net/) is required.


## Appendix C: How To Write Correct, Maintainable, Secure, and Easy-to-Test Code { #appendix-programming-testable }

#. I design applications that can be dynamically configured and automatically tested via a [CLI](https://en.wikipedia.org/wiki/Command-line_interface) script.
	* Ideally the CLI definition should already be part of the architectural specification of an application [domain specific language (DSL)](https://en.wikipedia.org/wiki/Domain-specific_language).
	* Ideally the CLI should be wrapped with an industry standard light weight embedded interpreter such as [Lua](https://www.lua.org/) or [FORTH/FICL](http://ficl.sourceforge.net/).
	* Tip: In debug mode _only_, the interpreter should be allowed to invoke O/S shell commands.
#. I design modules with built-in test points.
	* I write CLI scripts to access and to [fuzz](https://en.wikipedia.org/wiki/Fuzzing) these test points.
	* This technique promotes simple [regression testing](https://en.wikipedia.org/wiki/Regression_testing).
#. My preferred UX design is to have the UX generate CLI script - as opposed to directly invoking internal functions.
	* This allows UX actions to be _semantically_ captured as opposed to capturing low level UI events (e.g. individual mouse and keystroke events), and allows functional testing to be independent of the UX.
	* And it allows large test and configuration scenarios to be first sketched with the UX, and then to be extended with a text editor.
#. Especially in languages such as C/C++ that use manual memory management, using a tool such as [Valgrind](http://valgrind.org/) to discover memory leaks is critically important.
#. I liberally use both static and dynamic [assertions](https://en.wikipedia.org/wiki/Assertion_(software_development)) in my source code which are especially important during initial development. I am a big fan of the [design by contract](https://en.wikipedia.org/wiki/Design_by_contract) paradigm.
#. I use [lint](https://en.wikipedia.org/wiki/Lint_(software)), and I heavily make use of compiler attributes that enforce safe code.
#. I analyze my code with complexity metrics. See [cyclomatic complexity (McCabe)](https://en.wikipedia.org/wiki/Cyclomatic_complexity) and [Halstead complexity](https://en.wikipedia.org/wiki/Halstead_complexity_measures).
#. Never release code when the build process generates compiler warnings.
	* I have worked on too many projects where the build process generates hundreds of thousands of compiler warnings. In such a situation it is nearly impossible to determine which warnings are serious, so in fact all warnings are ignored.
#. A necessary condition for secure code is that the code first must be correct. See the Google Tech-Talk [The Lazy Programmer's Guide To Computer Security](https://www.youtube.com/watch?v=eL5o4PFuxTY).
#. And after all of the above techniques have been incorporated into the implementation, still the most efficient way to flush out 50% of the bugs is an informal code review with a colleague where the programmer must explain every line of his code. Typically during his explanation, the programmer has many "aha" moments when recognizing many of his own bugs.


## Colophon

* __Generator:__ This document was generated using the [Pandoc](http://www.pandoc.org) universal document converter extended [Markdown](https://en.wikipedia.org/wiki/Markdown) engine, along with the [Jinja2](http://jinja.pocoo.org/) macro/template preprocessor. See the source code at my [github site](https://github.com/avraham-bernstein/avraham-bernstein.github.io/tree/master).

* __Safety & non-annoyment pledge:__ This document is free of scripts, frames, advertisements, and animations.
%% if WRITER == 'html5'
<!-- This pledge was originally coined by David Pogue -->
%% endif

%% if WRITER == 'html5'
* __[WCAG](https://www.w3.org/TR/WCAG20/) blind accessibility conformance:__ This document contains text alternatives for images, and is tab navigable - for sections, subsections, paragraphs, list items, and links.
%% endif


%% if WRITER == 'html5' and FULL
{{NL}}
## Footnotes
%% endif
